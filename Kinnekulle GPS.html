<!DOCTYPE html>
<html lang="sv">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#2563eb">
<title>RailTimer ‚Äì G√•ngtidsm√§tare f√∂r t√•g</title>
<link rel="manifest" href="kinnekulle-gps.webmanifest">
<link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<style>
  :root{
    --bg:#1a1d23;
    --bg-solid:#0d0f12;
    --ink:#e8eaed;
    --ink-dim:#9aa0a6;
    --mut:#6b7280;
    --pri:#22c55e;
    --pri-dark:#16a34a;
    --pri-glow:rgba(34,197,94,0.15);
    --sec:#f59e0b;
    --b:#2d3139;
    --b-light:#3d4149;
    --soft:rgba(34,197,94,0.1);
    --softb:#22c55e;
    --err:#ef4444;
    --err-bg:rgba(239,68,68,0.15);
    --good:#22c55e;
    --good-bg:rgba(34,197,94,0.15);
    --card-bg:#1e2128;
    --warn:#f59e0b;
    --warn-bg:rgba(245,158,11,0.15);
    --blue:#3b82f6;
    --blue-bg:rgba(59,130,246,0.15);
  }
  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html{font-size:15px}
  body{
    font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
    margin:0;
    padding:0;
    line-height:1.5;
    background:var(--bg-solid);
    color:var(--ink);
    min-height:100vh;
    min-height:100dvh;
  }
  header{
    position:sticky;
    top:0;
    background:var(--bg);
    padding:.75rem 1rem;
    margin:0;
    border-bottom:1px solid var(--b);
    z-index:10;
  }
  h1{
    margin:0 0 .5rem;
    font-size:1.1rem;
    font-weight:600;
    color:var(--ink);
    letter-spacing:-0.01em;
  }
  h1::before{content:'üöÇ '}
  h2{
    margin:1.25rem 0 .75rem;
    font-size:1rem;
    font-weight:600;
    color:var(--ink);
  }
  h2::before{content:''}
  main{padding:.75rem;max-width:600px;margin:0 auto}
  .bar{display:flex;gap:.4rem;flex-wrap:wrap;align-items:center}
  .row{display:flex;gap:.4rem;flex-wrap:wrap}
  .grow{flex:1 1 auto}
  .form-group{margin:.5rem 0}
  label{display:block;margin:.2rem 0;font-weight:500;color:var(--ink-dim);font-size:.8rem;text-transform:uppercase;letter-spacing:.03em}
  input,select,button,textarea{
    font-size:.95rem;
    padding:.5rem .75rem;
    border:1px solid var(--b);
    border-radius:6px;
    font-family:inherit;
    background:var(--card-bg);
    color:var(--ink);
    transition:border-color 0.15s,box-shadow 0.15s;
  }
  input:focus,select:focus,textarea:focus{
    outline:none;
    border-color:var(--pri);
    box-shadow:0 0 0 2px var(--pri-glow);
  }
  input[type="checkbox"]{
    padding:0;
    width:1.1rem;
    height:1.1rem;
    border-radius:4px;
    accent-color:var(--pri);
  }
  select{background:var(--card-bg)}
  button{
    cursor:pointer;
    font-weight:500;
    font-size:.85rem;
    padding:.4rem .7rem;
    transition:all 0.15s ease;
    border:1px solid var(--b);
    background:var(--card-bg);
    color:var(--ink);
  }
  button:hover:not(:disabled){background:var(--b)}
  button:active:not(:disabled){transform:scale(0.98)}
  button.primary{
    background:var(--pri);
    color:#000;
    border-color:var(--pri);
    font-weight:600;
  }
  button.primary:hover:not(:disabled){background:var(--pri-dark)}
  button.ghost{
    background:transparent;
    color:var(--pri);
    border-color:var(--b);
  }
  button.ghost:hover:not(:disabled){background:var(--pri-glow);border-color:var(--pri)}
  button.danger{
    background:transparent;
    color:var(--err);
    border-color:var(--b);
  }
  button.danger:hover:not(:disabled){background:var(--err-bg);border-color:var(--err)}
  button:disabled{opacity:.4;cursor:not-allowed}
  button.sm{padding:.25rem .5rem;font-size:.75rem}
  .cards{
    display:flex;
    flex-direction:column;
    gap:.5rem;
    margin:.75rem 0;
  }
  .card{
    border:1px solid var(--b);
    border-radius:10px;
    padding:.9rem 1rem;
    background:var(--card-bg);
    transition:border-color 0.2s,background 0.2s;
  }
  .card:hover{border-color:var(--b-light)}
  .card.active{
    border-color:var(--pri);
    background:linear-gradient(135deg, var(--card-bg) 0%, rgba(34,197,94,0.05) 100%);
    box-shadow:0 0 0 1px var(--pri-glow);
  }
  .card.done{opacity:0.6}
  .card-header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:.5rem;
    cursor:pointer;
    min-height:2.5rem;
  }
  .card h3{
    margin:0;
    font-size:1.1rem;
    font-weight:600;
    color:var(--ink);
    display:flex;
    align-items:center;
    gap:.5rem;
  }
  .card h3 .station-num{
    color:var(--mut);
    font-weight:400;
    font-size:.9rem;
    min-width:1.7rem;
  }
  .card-times{
    display:flex;
    gap:1rem;
    font-size:.9rem;
    color:var(--ink-dim);
    margin-top:.5rem;
  }
  .card-times strong{color:var(--ink);font-weight:600}
  .card-times .arr::before{content:'‚Üì ';color:var(--pri)}
  .card-times .dep::before{content:'‚Üë ';color:var(--sec)}
  .card-expand{
    max-height:0;
    overflow:hidden;
    transition:max-height 0.25s ease;
  }
  .card.expanded .card-expand{max-height:20rem}
  .card-expand-inner{
    padding-top:.6rem;
    margin-top:.5rem;
    border-top:1px solid var(--b);
  }
  .card-toggle{
    width:1.5rem;
    height:1.5rem;
    border-radius:4px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:.7rem;
    color:var(--mut);
    transition:transform 0.2s;
  }
  .card.expanded .card-toggle{transform:rotate(180deg)}

  /* Autocomplete station search */
  /* Header dropdown menus */
  .header-menu{position:relative}
  .header-menu-btn{
    min-width:auto;
    padding:.4rem .6rem;
  }
  .header-menu-dropdown{
    position:absolute;
    top:100%;
    right:0;
    min-width:160px;
    background:var(--card-bg);
    border:1px solid var(--b);
    border-radius:6px;
    margin-top:4px;
    z-index:100;
    box-shadow:0 4px 12px rgba(0,0,0,0.4);
    display:none;
  }
  .header-menu-dropdown.open{display:block}
  .header-menu-dropdown button{
    display:block;
    width:100%;
    text-align:left;
    border:none;
    border-radius:0;
    background:transparent;
    padding:.6rem .8rem;
    font-size:.85rem;
  }
  .header-menu-dropdown button:hover{background:var(--b)}
  .header-menu-dropdown button:first-child{border-radius:6px 6px 0 0}
  .header-menu-dropdown button:last-child{border-radius:0 0 6px 6px}
  .header-menu-dropdown hr{border:none;border-top:1px solid var(--b);margin:0}

  .station-search-container{position:relative;flex:1}
  .station-search{width:100%}
  .station-dropdown{
    position:absolute;
    top:100%;
    left:0;
    right:0;
    max-height:280px;
    overflow-y:auto;
    background:var(--card-bg);
    border:1px solid var(--pri);
    border-radius:6px;
    margin-top:2px;
    z-index:100;
    box-shadow:0 4px 12px rgba(0,0,0,0.4);
    display:none;
  }
  .station-dropdown.open{display:block}
  .station-dropdown-item{
    padding:.65rem .85rem;
    cursor:pointer;
    border-bottom:1px solid var(--b);
    display:flex;
    justify-content:space-between;
    align-items:center;
  }
  .station-dropdown-item:last-child{border-bottom:none}
  .station-dropdown-item:hover,.station-dropdown-item.selected{background:var(--pri-glow)}
  .station-dropdown-item .station-name{font-weight:500;color:var(--ink)}
  .station-dropdown-item .station-sig{font-size:.75rem;color:var(--mut)}
  .station-dropdown-item .station-dist{font-size:.75rem;color:var(--pri)}
  .station-section-header{
    padding:.4rem .85rem;
    font-size:.7rem;
    font-weight:600;
    color:var(--mut);
    text-transform:uppercase;
    letter-spacing:.04em;
    background:var(--bg);
    border-bottom:1px solid var(--b);
  }
  .loading-stations{
    padding:1rem;
    text-align:center;
    color:var(--mut);
    font-size:.85rem;
  }

  .meta{font-size:.75rem;color:var(--mut);line-height:1.4}
  .badge{
    background:var(--b);
    border-radius:4px;
    padding:.15rem .4rem;
    font-size:.7rem;
    font-weight:600;
    display:inline-flex;
    align-items:center;
    color:var(--ink-dim);
  }
  .badge.live{background:var(--good-bg);color:var(--good)}
  .badge.warn{background:var(--err-bg);color:var(--err)}
  .badge.early{background:var(--blue-bg);color:var(--blue)}
  .badge.late{background:var(--warn-bg);color:var(--warn)}
  .badge.very-late{background:var(--err-bg);color:var(--err)}
  .badge.dist{background:transparent;color:var(--ink-dim);font-weight:500;font-variant-numeric:tabular-nums}
  .scheduled{font-size:.7rem;color:var(--mut);margin:.15rem 0 0}
  .status-grid{
    display:grid;
    grid-template-columns:repeat(2,1fr);
    gap:.5rem;
    margin:.75rem 0;
  }
  .status-box{
    border:1px solid var(--b);
    border-radius:8px;
    padding:.6rem .75rem;
    background:var(--card-bg);
  }
  .status-box h4{
    margin:0 0 .2rem;
    font-size:.65rem;
    color:var(--mut);
    text-transform:uppercase;
    letter-spacing:.04em;
    font-weight:600;
  }
  .status-box strong{font-size:1rem;color:var(--ink);font-weight:600;display:block}
  .status-box .meta{margin-top:.15rem}
  .control-row{margin:.4rem 0}
  .control-row label{
    display:inline-flex;
    align-items:center;
    gap:.4rem;
    font-size:.8rem;
    color:var(--ink-dim);
    text-transform:none;
    letter-spacing:0;
    cursor:pointer;
  }
  .card-actions{margin-top:.5rem;gap:.4rem;flex-wrap:wrap}
  .table-wrap{overflow-x:auto;border-radius:8px;border:1px solid var(--b)}
  table{border-collapse:collapse;width:100%;background:var(--card-bg);font-size:.8rem}
  th,td{border:1px solid var(--b);padding:.5rem .6rem;text-align:left}
  th{background:var(--bg);color:var(--ink-dim);font-weight:600;font-size:.7rem;text-transform:uppercase;letter-spacing:.03em}
  td input{width:5rem;padding:.3rem .4rem;font-size:.8rem}
  details{
    border:1px solid var(--b);
    border-radius:8px;
    padding:.75rem;
    background:var(--card-bg);
    margin-top:1rem;
  }
  summary{cursor:pointer;font-weight:500;font-size:.9rem;color:var(--ink)}
  summary::before{content:'‚öôÔ∏è ';font-size:.8rem}
  footer{margin-top:2rem;color:var(--mut);font-size:.75rem;text-align:center;padding:.75rem}
  code{
    font-family:ui-monospace,monospace;
    font-size:.8rem;
    background:var(--b);
    color:var(--ink);
    padding:.15rem .35rem;
    border-radius:4px;
  }
  @media (max-width:640px){
    html{font-size:14px}
    header{padding:.6rem .75rem}
    h1{font-size:1rem}
    main{padding:.5rem}
    .status-grid{grid-template-columns:1fr 1fr}
    .status-box{padding:.5rem}
    .bar{gap:.3rem}
    button{padding:.35rem .6rem}
  }
  @media (min-width:641px){
    .cards{max-width:500px}
  }

  /* Large text mode */
  body.large-text{font-size:18px}
  body.large-text .card h3{font-size:1.4rem}
  body.large-text .card-times{font-size:1.1rem}
  body.large-text .badge{font-size:.9rem;padding:.25rem .5rem}
  body.large-text .status-box strong{font-size:1.2rem}
  body.large-text button{font-size:1rem;padding:.5rem .9rem}

  /* Landscape mode */
  @media (orientation:landscape) and (max-height:500px){
    header{padding:.4rem .75rem}
    header h1{font-size:.95rem;margin-bottom:.25rem}
    main{padding:.4rem}
    .card{padding:.5rem .7rem}
    .card h3{font-size:1rem}
    .card-times{font-size:.8rem}
    .cards{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:.4rem;
    }
    .status-grid{grid-template-columns:repeat(4,1fr);gap:.3rem}
    .status-box{padding:.4rem .5rem}
    .status-box h4{font-size:.6rem}
    .status-box strong{font-size:.85rem}
    #routeMap{height:100px}
  }

  /* Route map */
  #routeMapContainer{
    margin:.75rem 0;
    border:1px solid var(--b);
    border-radius:8px;
    background:var(--card-bg);
    overflow:hidden;
  }
  #routeMapContainer.collapsed #routeMap{display:none}
  .map-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:.5rem .75rem;
    cursor:pointer;
    background:var(--bg);
    border-bottom:1px solid var(--b);
  }
  .map-header h4{margin:0;font-size:.8rem;color:var(--ink-dim)}
  .map-toggle{font-size:.7rem;color:var(--mut)}
  #routeMap{height:150px;width:100%}
  #routeMap svg{width:100%;height:100%}
  .map-station{cursor:pointer}
  .map-station:hover circle{stroke-width:3}
  .map-pos-marker{filter:drop-shadow(0 0 4px var(--pri))}

  /* Station notes */
  .station-note{
    width:100%;
    min-height:2.5rem;
    resize:vertical;
    margin-top:.4rem;
    font-size:.85rem;
    font-family:inherit;
  }

  /* Statistics section */
  #statistics{margin-top:1.5rem}
  .stats-filters{
    display:flex;
    gap:.5rem;
    flex-wrap:wrap;
    margin-bottom:.75rem;
  }
  .stats-filters select{font-size:.8rem;padding:.3rem .5rem}
  .stats-card{
    border:1px solid var(--b);
    border-radius:8px;
    padding:.75rem;
    background:var(--card-bg);
    margin-bottom:.5rem;
  }
  .stats-card h4{margin:0 0 .5rem;font-size:.9rem;color:var(--ink)}
  .stats-row{
    display:flex;
    justify-content:space-between;
    font-size:.8rem;
    padding:.25rem 0;
    border-bottom:1px solid var(--b);
  }
  .stats-row:last-child{border-bottom:none}
  .stats-label{color:var(--ink-dim)}
  .stats-value{color:var(--ink);font-weight:500;font-variant-numeric:tabular-nums}
  .stats-bar{
    height:6px;
    background:var(--b);
    border-radius:3px;
    margin-top:.3rem;
    overflow:hidden;
  }
  .stats-bar-fill{height:100%;background:var(--pri);border-radius:3px}

  /* Delay summary in header during journey */
  #delaySummary{
    font-size:.75rem;
    padding:.2rem .5rem;
    border-radius:4px;
    display:none;
  }
  #delaySummary.on-time{background:var(--good-bg);color:var(--good)}
  #delaySummary.late{background:var(--warn-bg);color:var(--warn)}
  #delaySummary.very-late{background:var(--err-bg);color:var(--err)}
</style>
</head>
<body>
<header>
  <h1>RailTimer</h1>
  <div class="bar">
    <div class="header-menu">
      <button id="btnExportMenu" class="primary header-menu-btn" aria-label="Exportera">Exportera ‚ñæ</button>
      <div id="exportMenuDropdown" class="header-menu-dropdown">
        <button id="btnExportCSV">CSV (Excel)</button>
        <button id="btnExport">JSON</button>
      </div>
    </div>
    <button id="btnWakeLock" class="ghost" aria-pressed="false" aria-label="Hindra att sk√§rmen slocknar">Sk√§rm p√•</button>
    <button id="btnSound" class="ghost" aria-pressed="false" aria-label="Ljudsignaler av/p√•">Ljud av</button>
    <button id="btnTextSize" class="ghost" aria-label="V√§xla textstorlek">Aa</button>
    <span id="delaySummary"></span>
    <div class="header-menu">
      <button id="btnMoreMenu" class="ghost header-menu-btn" aria-label="Fler alternativ">‚ãÆ</button>
      <div id="moreMenuDropdown" class="header-menu-dropdown">
        <button id="btnStatistics">Statistik</button>
        <button id="btnSaveFile">Spara till fil</button>
        <button id="btnSync">Synka loggfil</button>
        <hr>
        <button id="btnClear" class="danger">T√∂m alla loggar</button>
        <hr>
        <button id="btnInstall" style="display:none">Installera app</button>
        <button id="btnUpdate" style="display:none">Uppdatera app</button>
      </div>
    </div>
    <span id="headerStatus" class="badge" style="display:none"></span>
    <span id="offlineIndicator" class="badge warn" style="display:none" role="status" aria-live="polite">Offline</span>
    <span id="logCountTop" class="badge" role="status" aria-live="polite" style="margin-left:auto">0</span>
    <span id="gpsStatusBadge" class="badge">GPS</span>
  </div>
</header>

<main>
  <section id="setup">
    <h2>1. St√§ll in resan</h2>
    <div class="row">
      <div class="form-group grow">
        <label for="trainNumber">T√•gnummer (valfritt)</label>
        <input id="trainNumber" type="text" placeholder="t.ex. 8074">
      </div>
      <div class="form-group grow">
        <label for="vehicleType">Fordonstyp *</label>
        <select id="vehicleType" required>
          <option value="">V√§lj fordonstyp...</option>
          <optgroup label="Motorvagnar">
            <option value="X2">X2 (X2000)</option>
            <option value="X3">X3 (SJ 3000)</option>
            <option value="X10">X10</option>
            <option value="X11">X11</option>
            <option value="X12">X12</option>
            <option value="X14">X14</option>
            <option value="X40">X40 (V√§stt√•g)</option>
            <option value="X50">X50 (Regina)</option>
            <option value="X51">X51 (Regina)</option>
            <option value="X52">X52 (Regina)</option>
            <option value="X53">X53 (Regina)</option>
            <option value="X54">X54 (Regina)</option>
            <option value="X55">X55 (Regina)</option>
            <option value="X60">X60 (Pendelt√•g)</option>
            <option value="X61">X61 (P√•gat√•g)</option>
            <option value="X62">X62 (Norrt√•g)</option>
            <option value="X74">X74 (Itino)</option>
            <option value="ER1">ER1 (M√§lart√•g)</option>
          </optgroup>
          <optgroup label="Lok + vagnar">
            <option value="Rc">Rc-lok</option>
            <option value="Rd">Rd-lok</option>
            <option value="TRAXX">TRAXX</option>
            <option value="Vectron">Vectron</option>
            <option value="T44">T44</option>
          </optgroup>
          <optgroup label="Dieselmotorvagnar">
            <option value="Y1">Y1</option>
            <option value="Y2">Y2</option>
            <option value="Y31">Y31 (Itino)</option>
            <option value="Y32">Y32 (Itino)</option>
          </optgroup>
          <optgroup label="√ñvrigt">
            <option value="Annat">Annat</option>
          </optgroup>
        </select>
      </div>
    </div>
    <div id="routeSuggestion" style="display:none;margin:.6rem 0;padding:.75rem;background:var(--pri-glow);border:1px solid var(--pri);border-radius:8px">
      <div style="display:flex;align-items:center;gap:.4rem;margin-bottom:.4rem">
        <span style="font-size:1rem">üí°</span>
        <strong style="color:var(--pri)">F√∂rslag fr√•n historik</strong>
      </div>
      <p id="suggestionText" style="margin:.2rem 0;font-size:.9rem;color:var(--ink)"></p>
      <div class="bar" style="margin-top:.5rem">
        <button id="btnAcceptSuggestion" class="primary">‚úì Anv√§nd</button>
        <button id="btnIgnoreSuggestion" class="ghost">√Ñndra</button>
      </div>
    </div>
    <div class="row">
      <div class="form-group station-search-container">
        <label for="startStation">Startstation</label>
        <input type="text" id="startStation" class="station-search" placeholder="S√∂k station..." autocomplete="off">
        <div id="startStationDropdown" class="station-dropdown"></div>
      </div>
      <div class="form-group station-search-container">
        <label for="endStation">Slutstation</label>
        <input type="text" id="endStation" class="station-search" placeholder="S√∂k station..." autocomplete="off">
        <div id="endStationDropdown" class="station-dropdown"></div>
      </div>
    </div>
    <div id="stationLoadStatus" class="loading-stations" style="display:none">Laddar stationer...</div>
    <div class="form-group">
      <label for="startNotes">Anteckningar (syns i rapporten)</label>
      <textarea id="startNotes" rows="2" placeholder="Skriv h√§r om du vill anteckna n√•got om m√§tningen ‚Ä¶"></textarea>
    </div>
    <div class="bar">
      <button id="btnStart" class="primary">Starta GPS-resan</button>
      <span id="setupError" class="badge warn" style="display:none"></span>
    </div>
  </section>

  <section id="journey" style="display:none">
    <h2 id="journeyTitle">Aktiv resa</h2>
    <div class="status-grid">
      <div class="status-box">
        <h4>GPS-status</h4>
        <strong id="gpsStatusText">‚Äì</strong>
        <div class="meta" id="gpsAccuracy">Noggrannhet: ‚Äì</div>
      </div>
      <div class="status-box">
        <h4>Senaste position</h4>
        <strong id="gpsCoords">‚Äì</strong>
        <div class="meta" id="gpsTimestamp">‚Äì</div>
      </div>
      <div class="status-box">
        <h4>Hastighet</h4>
        <strong id="gpsSpeed">‚Äì</strong>
        <div class="meta" id="gpsExtra">Ingen r√∂relse registrerad</div>
      </div>
      <div class="status-box">
        <h4>N√§sta station</h4>
        <strong id="nextStop">‚Äì</strong>
        <div class="meta" id="nextStopInfo">Ingen aktiv resa</div>
      </div>
    </div>
    <div class="bar" style="margin:1rem 0">
      <button id="btnFinish" class="primary">Avsluta & spara</button>
      <button id="btnAbort" class="danger">Avbryt resa</button>
      <span id="journeyMsg" class="badge" style="display:none"></span>
    </div>
    <div id="routeMapContainer">
      <div class="map-header" id="mapToggle">
        <h4>Karta</h4>
        <span class="map-toggle">Visa/D√∂lj</span>
      </div>
      <div id="routeMap"></div>
    </div>
    <div id="cards" class="cards"></div>
  </section>

  <section id="report" style="display:none">
    <h2>Rapport</h2>
    <div id="reportHTML"></div>
    <div class="bar" style="margin-top:1rem">
      <button id="btnNew" class="ghost">Starta ny m√§tning</button>
    </div>
  </section>

  <section id="statistics" style="display:none">
    <h2>Statistik</h2>
    <div class="stats-filters">
      <select id="statsVehicleFilter">
        <option value="">Alla fordon</option>
      </select>
      <select id="statsRouteFilter">
        <option value="">Alla str√§ckor</option>
      </select>
      <button id="btnCloseStats" class="ghost sm">St√§ng</button>
    </div>
    <div id="statsContent"></div>
  </section>

</main>

<footer>
  Tips: K√∂r sidan via <code>https://</code> p√• mobilen f√∂r att f√• tillg√•ng till h√∂guppl√∂st GPS. All data sparas endast lokalt i webbl√§saren.
</footer>

<script>
(function(){
  'use strict';

  const APP_VERSION = '2026-01-23b';
  const DEFAULT_RADIUS = 200;
  const EXTRA_MARGIN = 150;
  const SPEED_THRESHOLD_KMH = 5;
  const SPEED_THRESHOLD_MS = SPEED_THRESHOLD_KMH / 3.6;
  const CLOSE_APPROACH_EPS = 1; // meters
  const PASS_DISTANCE_MARGIN = 5; // meters before we consider leaving after pass
  const DEPART_REVERT_WINDOW_MS = 120000; // allow 2 min to re-time a premature departure
  const STORAGE_KEY_LOGS = 'kmon_gps_logs_v1';
  const STORAGE_KEY_STATIONS = 'kmon_gps_station_meta_v1';
  const STORAGE_KEY_SAVE_FILE = 'kmon_gps_file_handle_v1';
  const STORAGE_KEY_ROUTE_HISTORY = 'kmon_gps_route_history_v1';
  const STORAGE_KEY_ACTIVE_JOURNEY = 'railtimer_active_journey_v1';
  const STORAGE_KEY_ALL_STATIONS = 'kmon_all_stations_v1';
  const STORAGE_KEY_RECENT_STATIONS = 'kmon_recent_stations_v1';
  const STORAGE_KEY_SOUND_ENABLED = 'railtimer_sound_v1';
  const STORAGE_KEY_LARGE_TEXT = 'railtimer_large_text_v1';
  const STATIONS_CACHE_MAX_AGE_MS = 7 * 24 * 60 * 60 * 1000; // 7 dagar
  const MAX_RECENT_STATIONS = 20;
  const TRAFIKVERKET_API_KEY = '1acaea82911c472cb3409d57ae19707f';
  const TRAFIKVERKET_API_URL = 'https://api.trafikinfo.trafikverket.se/v2/data.json';

  // Stationer h√§mtas dynamiskt fr√•n Trafikverket API
  // baseStations anv√§nds endast som fallback om API:t misslyckas
  const baseStations = [];

  const els = {
    startInput: document.getElementById('startStation'),
    endInput: document.getElementById('endStation'),
    startDropdown: document.getElementById('startStationDropdown'),
    endDropdown: document.getElementById('endStationDropdown'),
    stationLoadStatus: document.getElementById('stationLoadStatus'),
    cards: document.getElementById('cards'),
    setup: document.getElementById('setup'),
    journey: document.getElementById('journey'),
    report: document.getElementById('report'),
    saveBtn: document.getElementById('btnSaveFile'),
    setupError: document.getElementById('setupError'),
    journeyMsg: document.getElementById('journeyMsg'),
    reportHTML: document.getElementById('reportHTML'),
    gpsStatusBadge: document.getElementById('gpsStatusBadge'),
    gpsStatusText: document.getElementById('gpsStatusText'),
    gpsAccuracy: document.getElementById('gpsAccuracy'),
    gpsCoords: document.getElementById('gpsCoords'),
    gpsTimestamp: document.getElementById('gpsTimestamp'),
    gpsSpeed: document.getElementById('gpsSpeed'),
    gpsExtra: document.getElementById('gpsExtra'),
    nextStop: document.getElementById('nextStop'),
    nextStopInfo: document.getElementById('nextStopInfo'),
    journeyTitle: document.getElementById('journeyTitle'),
    logCountTop: document.getElementById('logCountTop'),
    installBtn: document.getElementById('btnInstall'),
    updateBtn: document.getElementById('btnUpdate'),
    headerStatus: document.getElementById('headerStatus'),
    wakeBtn: document.getElementById('btnWakeLock')
  };

  let stationOverrides = loadStationOverrides();
  let stationCatalog = composeStationCatalog();
  let currentSuggestion = null;
  let allStationsCache = [];
  let recentStations = loadRecentStations();
  let userLocation = null;
  let selectedStartStation = null;
  let selectedEndStation = null;
  let activeDropdown = null;

  const state = {
    running: false,
    watchId: null,
    route: [],
    trainNumber: '',
    vehicleType: '',
    notes: '',
    startedAt: null,
    lastPosition: null,
    lastFixTime: null,
    lastSpeed: null,
    lastSpeedTime: null,
    lastReachedIndex: 0,
    nextIndex: null,
    awaitingDepartureIndex: null,
    departureProvisionalIdx: null,
    autoReason: '',
    aborted: false
  };
  let deferredInstallPrompt = null;
  let wakeLockSentinel = null;
  let keepScreenAwake = false;
  let pendingServiceWorker = null;
  let updateTriggered = false;
  let hadController = !!navigator.serviceWorker.controller;
  let expandedCards = new Set(); // Track which cards are expanded

  // Settings
  let soundEnabled = localStorage.getItem(STORAGE_KEY_SOUND_ENABLED) === 'true';
  let largeTextEnabled = localStorage.getItem(STORAGE_KEY_LARGE_TEXT) === 'true';
  let audioCtx = null;

  async function init(){
    updateLogCount();
    bindEvents();
    setupPWA();
    updateWakeButton();
    setupOnlineStatus();
    setupStationSearch();
    applyStoredSettings();
    await loadAllStations();
    getUserLocation();
    checkForInterruptedJourney();
  }

  // Vibration feedback for arrivals/departures
  function vibrate(pattern){
    if('vibrate' in navigator){
      try{ navigator.vibrate(pattern); }catch(e){}
    }
  }

  // Sound feedback for arrivals/departures
  function playTone(frequency, duration, count=1){
    if(!soundEnabled) return;
    try{
      if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if(audioCtx.state === 'suspended') audioCtx.resume();

      for(let i=0; i<count; i++){
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.frequency.value = frequency;
        osc.type = 'sine';
        gain.gain.value = 0.3;

        const startTime = audioCtx.currentTime + i * (duration/1000 + 0.1);
        osc.start(startTime);
        gain.gain.exponentialRampToValueAtTime(0.01, startTime + duration/1000);
        osc.stop(startTime + duration/1000);
      }
    }catch(e){ console.log('Audio error:', e); }
  }

  function playArrivalSound(){
    playTone(800, 150, 2); // Two short high beeps
  }

  function playDepartureSound(){
    playTone(600, 300, 1); // One longer lower beep
  }

  function toggleSound(){
    soundEnabled = !soundEnabled;
    localStorage.setItem(STORAGE_KEY_SOUND_ENABLED, soundEnabled);
    updateSoundButton();
    // Play test sound when enabling
    if(soundEnabled) playTone(800, 100, 1);
  }

  function updateSoundButton(){
    const btn = document.getElementById('btnSound');
    if(!btn) return;
    btn.textContent = soundEnabled ? 'Ljud p√•' : 'Ljud av';
    btn.setAttribute('aria-pressed', soundEnabled);
    btn.classList.toggle('primary', soundEnabled);
    btn.classList.toggle('ghost', !soundEnabled);
  }

  function toggleLargeText(){
    largeTextEnabled = !largeTextEnabled;
    localStorage.setItem(STORAGE_KEY_LARGE_TEXT, largeTextEnabled);
    document.body.classList.toggle('large-text', largeTextEnabled);
    updateTextSizeButton();
  }

  function updateTextSizeButton(){
    const btn = document.getElementById('btnTextSize');
    if(!btn) return;
    btn.classList.toggle('primary', largeTextEnabled);
    btn.classList.toggle('ghost', !largeTextEnabled);
  }

  function applyStoredSettings(){
    if(largeTextEnabled) document.body.classList.add('large-text');
    updateSoundButton();
    updateTextSizeButton();
  }

  // Online/offline status
  function setupOnlineStatus(){
    updateOnlineStatus();
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);
  }

  function updateOnlineStatus(){
    const indicator = document.getElementById('offlineIndicator');
    if(!indicator) return;
    if(navigator.onLine){
      indicator.style.display = 'none';
    }else{
      indicator.style.display = 'inline-flex';
    }
  }

  // === Station Search & Loading ===

  function loadRecentStations(){
    try{
      const data = localStorage.getItem(STORAGE_KEY_RECENT_STATIONS);
      return data ? JSON.parse(data) : [];
    }catch(e){ return []; }
  }

  function saveRecentStations(){
    try{
      localStorage.setItem(STORAGE_KEY_RECENT_STATIONS, JSON.stringify(recentStations.slice(0, MAX_RECENT_STATIONS)));
    }catch(e){}
  }

  function addToRecentStations(station){
    if(!station || !station.name) return;
    recentStations = recentStations.filter(s => s.name !== station.name);
    recentStations.unshift({ name: station.name, sig: station.sig, lat: station.lat, lon: station.lon });
    recentStations = recentStations.slice(0, MAX_RECENT_STATIONS);
    saveRecentStations();
  }

  function getUserLocation(){
    if(!navigator.geolocation) return;
    navigator.geolocation.getCurrentPosition(
      pos => { userLocation = { lat: pos.coords.latitude, lon: pos.coords.longitude }; },
      () => {},
      { enableHighAccuracy: false, timeout: 5000, maximumAge: 60000 }
    );
  }

  async function loadAllStations(){
    els.stationLoadStatus.style.display = 'block';
    els.stationLoadStatus.textContent = 'Laddar stationer fr√•n Trafikverket...';

    // Try cache first
    const cached = loadStationsFromCache();
    if(cached && cached.length > 0){
      allStationsCache = cached;
      els.stationLoadStatus.style.display = 'none';
      return;
    }

    // Fetch from API
    try{
      const stations = await fetchAllStationsFromAPI();
      if(stations && stations.length > 0){
        allStationsCache = stations;
        saveStationsToCache(stations);
        els.stationLoadStatus.style.display = 'none';
      }else{
        throw new Error('Inga stationer h√§mtade');
      }
    }catch(e){
      console.error('Failed to load stations:', e);
      // Fallback to baseStations
      allStationsCache = baseStations.map(s => ({ name: s.name, sig: '', lat: s.lat, lon: s.lon }));
      els.stationLoadStatus.textContent = 'Kunde inte h√§mta stationer, anv√§nder lokal lista';
      setTimeout(() => { els.stationLoadStatus.style.display = 'none'; }, 3000);
    }
  }

  function loadStationsFromCache(){
    try{
      const data = localStorage.getItem(STORAGE_KEY_ALL_STATIONS);
      if(!data) return null;
      const parsed = JSON.parse(data);
      if(Date.now() - parsed.timestamp > STATIONS_CACHE_MAX_AGE_MS) return null;
      return parsed.stations;
    }catch(e){ return null; }
  }

  function saveStationsToCache(stations){
    try{
      localStorage.setItem(STORAGE_KEY_ALL_STATIONS, JSON.stringify({
        timestamp: Date.now(),
        stations: stations
      }));
    }catch(e){}
  }

  async function fetchAllStationsFromAPI(){
    const xmlRequest = `<REQUEST>
      <LOGIN authenticationkey="${TRAFIKVERKET_API_KEY}" />
      <QUERY objecttype="TrainStation" schemaversion="1.4">
        <FILTER>
          <EQ name="Advertised" value="true" />
        </FILTER>
        <INCLUDE>AdvertisedLocationName</INCLUDE>
        <INCLUDE>LocationSignature</INCLUDE>
        <INCLUDE>Geometry.WGS84</INCLUDE>
      </QUERY>
    </REQUEST>`;

    const resp = await fetch(TRAFIKVERKET_API_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/xml' },
      body: xmlRequest
    });

    if(!resp.ok) throw new Error('API error: ' + resp.status);
    const data = await resp.json();

    if(!data.RESPONSE || !data.RESPONSE.RESULT || !data.RESPONSE.RESULT[0]) {
      throw new Error('Invalid API response');
    }

    const trainStations = data.RESPONSE.RESULT[0].TrainStation || [];
    return trainStations.map(st => {
      let lat = null, lon = null;
      if(st.Geometry && st.Geometry.WGS84){
        const match = st.Geometry.WGS84.match(/POINT\s*\(\s*([\d.-]+)\s+([\d.-]+)\s*\)/i);
        if(match){
          lon = parseFloat(match[1]);
          lat = parseFloat(match[2]);
        }
      }
      return {
        name: st.AdvertisedLocationName || '',
        sig: st.LocationSignature || '',
        lat: lat,
        lon: lon
      };
    }).filter(s => s.name && s.lat && s.lon).sort((a, b) => a.name.localeCompare(b.name, 'sv'));
  }

  function filterStations(query, limit = 30){
    const q = (query || '').toLowerCase().trim();
    const results = [];
    const seen = new Set();

    // If empty query, show recent + nearby
    if(!q){
      // Add recent stations
      for(const rs of recentStations){
        const st = allStationsCache.find(s => s.name === rs.name);
        if(st && !seen.has(st.name)){
          results.push({ ...st, section: 'recent' });
          seen.add(st.name);
        }
      }

      // Add nearby stations if we have location
      if(userLocation){
        const withDist = allStationsCache.map(s => ({
          ...s,
          dist: haversine(userLocation.lat, userLocation.lon, s.lat, s.lon)
        })).sort((a, b) => a.dist - b.dist);

        for(const st of withDist.slice(0, 10)){
          if(!seen.has(st.name)){
            results.push({ ...st, section: 'nearby' });
            seen.add(st.name);
          }
        }
      }

      return results.slice(0, limit);
    }

    // Search by name or signature
    const matches = allStationsCache.filter(s => {
      const nameLower = s.name.toLowerCase();
      const sigLower = (s.sig || '').toLowerCase();
      return nameLower.startsWith(q) || sigLower.startsWith(q) || nameLower.includes(q);
    });

    // Sort: exact start match first, then by name
    matches.sort((a, b) => {
      const aStarts = a.name.toLowerCase().startsWith(q) ? 0 : 1;
      const bStarts = b.name.toLowerCase().startsWith(q) ? 0 : 1;
      if(aStarts !== bStarts) return aStarts - bStarts;
      return a.name.localeCompare(b.name, 'sv');
    });

    // Add distance if available
    if(userLocation){
      for(const st of matches){
        st.dist = haversine(userLocation.lat, userLocation.lon, st.lat, st.lon);
      }
    }

    return matches.slice(0, limit);
  }

  function setupStationSearch(){
    const inputs = [
      { input: els.startInput, dropdown: els.startDropdown, type: 'start' },
      { input: els.endInput, dropdown: els.endDropdown, type: 'end' }
    ];

    for(const cfg of inputs){
      cfg.input.addEventListener('focus', () => {
        activeDropdown = cfg.type;
        updateDropdown(cfg, cfg.input.value);
      });

      cfg.input.addEventListener('input', () => {
        updateDropdown(cfg, cfg.input.value);
      });

      cfg.input.addEventListener('blur', () => {
        setTimeout(() => {
          cfg.dropdown.classList.remove('open');
        }, 200);
      });

      cfg.input.addEventListener('keydown', (e) => {
        if(e.key === 'Escape'){
          cfg.dropdown.classList.remove('open');
          cfg.input.blur();
        }else if(e.key === 'ArrowDown' || e.key === 'ArrowUp'){
          e.preventDefault();
          navigateDropdown(cfg, e.key === 'ArrowDown' ? 1 : -1);
        }else if(e.key === 'Enter'){
          e.preventDefault();
          selectHighlightedItem(cfg);
        }
      });

      cfg.dropdown.addEventListener('mousedown', (e) => {
        e.preventDefault();
        const item = e.target.closest('.station-dropdown-item');
        if(item){
          selectStation(cfg, item.dataset.name);
        }
      });
    }

    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
      if(!e.target.closest('.station-search-container')){
        els.startDropdown.classList.remove('open');
        els.endDropdown.classList.remove('open');
      }
    });
  }

  function updateDropdown(cfg, query){
    const stations = filterStations(query);
    let html = '';
    let currentSection = '';

    for(const st of stations){
      if(st.section && st.section !== currentSection){
        currentSection = st.section;
        const sectionLabel = st.section === 'recent' ? 'Senast anv√§nda' : 'I n√§rheten';
        html += `<div class="station-section-header">${sectionLabel}</div>`;
      }
      const distText = st.dist != null ? `${formatDistance(st.dist)}` : '';
      html += `<div class="station-dropdown-item" data-name="${escapeHtml(st.name)}">
        <span class="station-name">${escapeHtml(st.name)}</span>
        <span>
          <span class="station-sig">${escapeHtml(st.sig || '')}</span>
          ${distText ? `<span class="station-dist">${distText}</span>` : ''}
        </span>
      </div>`;
    }

    if(stations.length === 0){
      html = '<div class="loading-stations">Inga stationer hittades</div>';
    }

    cfg.dropdown.innerHTML = html;
    cfg.dropdown.classList.add('open');
  }

  function navigateDropdown(cfg, direction){
    const items = cfg.dropdown.querySelectorAll('.station-dropdown-item');
    if(items.length === 0) return;

    const current = cfg.dropdown.querySelector('.station-dropdown-item.selected');
    let idx = current ? Array.from(items).indexOf(current) : -1;
    idx += direction;
    if(idx < 0) idx = items.length - 1;
    if(idx >= items.length) idx = 0;

    items.forEach(it => it.classList.remove('selected'));
    items[idx].classList.add('selected');
    items[idx].scrollIntoView({ block: 'nearest' });
  }

  function selectHighlightedItem(cfg){
    const selected = cfg.dropdown.querySelector('.station-dropdown-item.selected');
    if(selected){
      selectStation(cfg, selected.dataset.name);
    }else{
      const first = cfg.dropdown.querySelector('.station-dropdown-item');
      if(first) selectStation(cfg, first.dataset.name);
    }
  }

  function selectStation(cfg, name){
    const station = allStationsCache.find(s => s.name === name);
    if(!station) return;

    cfg.input.value = station.name;
    cfg.dropdown.classList.remove('open');

    if(cfg.type === 'start'){
      selectedStartStation = station;
    }else{
      selectedEndStation = station;
    }

    addToRecentStations(station);
  }

  function getSelectedRoute(){
    // Returns the array of stations between start and end
    if(!selectedStartStation || !selectedEndStation) return null;
    if(selectedStartStation.name === selectedEndStation.name) return null;

    // Check if both are in our station catalog (for route building)
    const startIdx = stationCatalog.findIndex(s => s.name === selectedStartStation.name);
    const endIdx = stationCatalog.findIndex(s => s.name === selectedEndStation.name);

    if(startIdx >= 0 && endIdx >= 0){
      // Both in catalog - use existing route logic
      const forward = startIdx < endIdx;
      return forward ? stationCatalog.slice(startIdx, endIdx + 1) : stationCatalog.slice(endIdx, startIdx + 1).reverse();
    }

    // Stations not in catalog - just return start and end
    return [
      { ...selectedStartStation, radius: DEFAULT_RADIUS },
      { ...selectedEndStation, radius: DEFAULT_RADIUS }
    ];
  }

  function bindEvents(){
    document.getElementById('btnStart').addEventListener('click', startJourney);
    document.getElementById('btnAbort').addEventListener('click', () => stopJourney(true, 'Resan avbr√∂ts manuellt'));
    document.getElementById('btnFinish').addEventListener('click', () => stopJourney(false, 'Avslutad manuellt'));
    document.getElementById('btnExport').addEventListener('click', () => { closeAllMenus(); exportLogs(); });
    document.getElementById('btnExportCSV').addEventListener('click', () => { closeAllMenus(); exportLogsCSV(); });
    document.getElementById('btnSaveFile').addEventListener('click', () => { closeAllMenus(); saveLogsToFile(); });
    document.getElementById('btnClear').addEventListener('click', () => { closeAllMenus(); clearLogs(); });
    document.getElementById('btnSync').addEventListener('click', () => { closeAllMenus(); syncLogs(); });
    document.getElementById('btnNew').addEventListener('click', resetForNewRun);
    els.cards.addEventListener('click', handleCardButton);
    els.cards.addEventListener('change', handleCardChange);
    if(els.wakeBtn){
      els.wakeBtn.addEventListener('click', toggleWakeLock);
    }
    if(els.updateBtn){
      els.updateBtn.addEventListener('click', ()=> {
        closeAllMenus();
        if(pendingServiceWorker){
          updateTriggered=true;
          els.updateBtn.disabled=true;
          showHeaderStatus('Uppdaterar appen‚Ä¶', false);
          pendingServiceWorker.postMessage({type:'SKIP_WAITING'});
          pendingServiceWorker=null;
        }else{
          window.location.reload();
        }
      });
    }
    document.addEventListener('visibilitychange', handleVisibilityChange);

    // Header dropdown menus
    document.getElementById('btnExportMenu').addEventListener('click', (e) => {
      e.stopPropagation();
      toggleMenu('exportMenuDropdown');
    });
    document.getElementById('btnMoreMenu').addEventListener('click', (e) => {
      e.stopPropagation();
      toggleMenu('moreMenuDropdown');
    });
    document.addEventListener('click', closeAllMenus);

    // Sound and text size toggles
    document.getElementById('btnSound').addEventListener('click', toggleSound);
    document.getElementById('btnTextSize').addEventListener('click', toggleLargeText);

    // Statistics
    document.getElementById('btnStatistics').addEventListener('click', () => {
      closeAllMenus();
      showStatistics();
    });
    document.getElementById('btnCloseStats').addEventListener('click', hideStatistics);
    document.getElementById('statsVehicleFilter').addEventListener('change', renderStatistics);
    document.getElementById('statsRouteFilter').addEventListener('change', renderStatistics);

    // Map toggle
    document.getElementById('mapToggle').addEventListener('click', () => {
      document.getElementById('routeMapContainer').classList.toggle('collapsed');
    });

    // Station notes (delegated)
    els.cards.addEventListener('input', handleCardInput);

    document.getElementById('trainNumber').addEventListener('input', handleTrainNumberInput);
    document.getElementById('btnAcceptSuggestion').addEventListener('click', acceptSuggestion);
    document.getElementById('btnIgnoreSuggestion').addEventListener('click', () => {
      document.getElementById('routeSuggestion').style.display='none';
      currentSuggestion = null;
    });
  }

  function toggleMenu(menuId){
    const menu = document.getElementById(menuId);
    const wasOpen = menu.classList.contains('open');
    closeAllMenus();
    if(!wasOpen){
      menu.classList.add('open');
    }
  }

  function closeAllMenus(){
    document.querySelectorAll('.header-menu-dropdown').forEach(m => m.classList.remove('open'));
  }

  async function startJourney(){
    speedHistory.length=0; // nollst√§ller tidigare hastighetsposter inf√∂r ny resa
    state.awaitingDepartureIndex=null;
    state.departureProvisionalIdx=null;
    state.lastSpeed=null;
    state.lastSpeedTime=null;

    // Validate selection
    if(!selectedStartStation || !selectedEndStation){
      showSetupError('V√§lj start- och slutstation.');
      return;
    }
    const startName = selectedStartStation.name;
    const endName = selectedEndStation.name;
    if(startName === endName){
      showSetupError('Start- och slutstation m√•ste vara olika.');
      return;
    }

    const vehicleType = document.getElementById('vehicleType').value;
    if(!vehicleType){
      showSetupError('V√§lj fordonstyp.');
      return;
    }

    const trainNumber = (document.getElementById('trainNumber').value||'').trim();
    let slice = null;
    let timetableResult = null;

    // If train number provided, try to build route from timetable
    if(trainNumber){
      showSetupError('');
      document.getElementById('btnStart').disabled = true;
      document.getElementById('btnStart').textContent = 'H√§mtar tidtabell...';

      timetableResult = await fetchTimetable(trainNumber, new Date());

      document.getElementById('btnStart').disabled = false;
      document.getElementById('btnStart').textContent = 'Starta GPS-resan';

      if(timetableResult.success && timetableResult.stationStops && timetableResult.stationStops.length > 0){
        // Build route from timetable - get all stations between start and end
        slice = buildRouteFromTimetable(timetableResult, selectedStartStation.sig, selectedEndStation.sig);
      }
    }

    // Fallback: try stationCatalog or just start/end
    if(!slice || slice.length === 0){
      const startIdx = stationCatalog.findIndex(s => s.name === startName || s.name.startsWith(startName) || startName.startsWith(s.name));
      const endIdx = stationCatalog.findIndex(s => s.name === endName || s.name.startsWith(endName) || endName.startsWith(s.name));

      if(startIdx >= 0 && endIdx >= 0 && startIdx !== endIdx){
        const forward = startIdx < endIdx;
        slice = forward ? stationCatalog.slice(startIdx, endIdx + 1) : stationCatalog.slice(endIdx, startIdx + 1).reverse();
      }else{
        // Just start and end
        slice = [
          { ...selectedStartStation, radius: DEFAULT_RADIUS },
          { ...selectedEndStation, radius: DEFAULT_RADIUS }
        ];
      }
    }

    const route = slice.map((st, idx) => ({
      name:st.name,
      sig:st.sig||'',
      lat:st.lat,
      lon:st.lon,
      radius:isFinite(st.radius)?st.radius:DEFAULT_RADIUS,
      customRadius:!!st.customRadius,
      actualArrival:null,
      actualDeparture:null,
      scheduledArrival:st.scheduledArrival||null,
      scheduledDeparture:st.scheduledDeparture||null,
      arrivalSource:'',
      departSource:'',
      arrivalPosition:null,
      departurePosition:null,
      shouldStop:true,
      excludeInboundRun:false,
      inZone:false,
      lastSeenDistance:null,
      passThrough:false,
      needsArrivalRetiming:false,
      reachedLowSpeed:false,
      closestDistance:null,
      closestTime:null,
      closestPosition:null,
      departureProvisional:false,
      departureProvisionalAt:null,
      order:idx+1
    }));
    state.route=route;
    state.running=true;
    state.trainNumber=trainNumber;
    state.vehicleType=vehicleType;
    state.notes=(document.getElementById('startNotes').value||'').trim();
    state.startedAt=new Date();
    state.lastReachedIndex=0;
    state.nextIndex=route.length>1?1:null;
    state.autoReason='';
    state.aborted=false;
    hideSetupError();
    els.setup.style.display='none';
    els.journey.style.display='block';
    els.report.style.display='none';
    els.journeyTitle.textContent=`${startName} ‚Üí ${endName} ‚Ä¢ ${state.vehicleType} ‚Ä¢ t√•g ${state.trainNumber||'‚Äì'}`;
    els.journeyMsg.style.display='none';
    renderRouteCards();
    renderRouteMap();
    requestGpsWatch();

    if(timetableResult && timetableResult.success){
      const stopCount = state.route.length;
      showJourneyMessage(`Tidtabell h√§mtad! (${stopCount} stationer)`, false);
      setTimeout(() => { els.journeyMsg.style.display='none'; }, 3000);
    }else if(trainNumber && timetableResult){
      showJourneyMessage(`Tidtabell: ${timetableResult.error}`, true);
      setTimeout(() => { els.journeyMsg.style.display='none'; }, 8000);
    }
  }

  function buildRouteFromTimetable(timetableResult, startSig, endSig){
    const { timetable, stationStops } = timetableResult;
    if(!timetable || !stationStops) return null;

    // Build ordered list of stations from timetable
    const stationsWithTime = [];
    for(const sig of stationStops){
      const info = timetable[sig];
      if(!info) continue;

      // Find station in allStationsCache by signature
      const stationData = allStationsCache.find(s => s.sig === sig);
      if(!stationData || !stationData.lat || !stationData.lon) continue;

      // Get time for sorting (use departure or arrival)
      const time = info.departure || info.arrival;
      if(!time) continue;

      stationsWithTime.push({
        sig: sig,
        name: stationData.name,
        lat: stationData.lat,
        lon: stationData.lon,
        radius: DEFAULT_RADIUS,
        time: time,
        scheduledArrival: info.arrival || null,
        scheduledDeparture: info.departure || null
      });
    }

    // Sort by time
    stationsWithTime.sort((a, b) => a.time - b.time);

    // Find start and end indices
    let startIdx = stationsWithTime.findIndex(s => s.sig === startSig);
    let endIdx = stationsWithTime.findIndex(s => s.sig === endSig);

    // If exact match not found, try matching by name similarity
    if(startIdx < 0 && selectedStartStation){
      startIdx = stationsWithTime.findIndex(s =>
        s.name === selectedStartStation.name ||
        s.name.includes(selectedStartStation.name) ||
        selectedStartStation.name.includes(s.name)
      );
    }
    if(endIdx < 0 && selectedEndStation){
      endIdx = stationsWithTime.findIndex(s =>
        s.name === selectedEndStation.name ||
        s.name.includes(selectedEndStation.name) ||
        selectedEndStation.name.includes(s.name)
      );
    }

    // If still not found, try first and last
    if(startIdx < 0) startIdx = 0;
    if(endIdx < 0) endIdx = stationsWithTime.length - 1;

    // Extract the route slice
    if(startIdx <= endIdx){
      return stationsWithTime.slice(startIdx, endIdx + 1);
    }else{
      // Reverse direction
      return stationsWithTime.slice(endIdx, startIdx + 1).reverse();
    }
  }

  function requestGpsWatch(){
    if(!navigator.geolocation){
      updateGpsStatus(null, { message:'GPS saknas i webbl√§saren.' });
      showJourneyMessage('GPS st√∂ds inte i den h√§r webbl√§saren.', true);
      return;
    }
    if(state.watchId!==null) navigator.geolocation.clearWatch(state.watchId);
    const startWatch=()=>{
      state.watchId = navigator.geolocation.watchPosition(handlePosition, handlePositionError, {
        enableHighAccuracy:true,
        maximumAge:1000,
        timeout:15000
      });
      updateGpsStatus(null, { message:'V√§ntar p√• f√∂rsta fix‚Ä¶' });
    };
    navigator.geolocation.getCurrentPosition(pos=>{
      state.lastPosition=pos;
      state.lastFixTime=Date.now();
      updateGpsStatus(pos);
      startWatch();
    }, err=>{
      if(err && err.code===err.PERMISSION_DENIED){
        updateGpsStatus(null, { message:'Plats nekad ‚Äì till√•t GPS i webbl√§saren.' });
        showJourneyMessage('Till√•t plats/GPS f√∂r den h√§r sidan och starta om.', true);
        return;
      }
      startWatch();
    }, { enableHighAccuracy:true, maximumAge:1000, timeout:8000 });
  }

  function handlePosition(pos){
    state.lastPosition=pos;
    state.lastFixTime=Date.now();
    updateGpsStatus(pos);
    if(!state.running) return;
    const lat=pos.coords.latitude;
    const lon=pos.coords.longitude;
    const acc=pos.coords.accuracy;
    const speed=pos.coords.speed!=null?pos.coords.speed:estimateSpeedFromHistory(pos);
    state.lastSpeed=speed;
    state.lastSpeedTime=pos.timestamp||Date.now();
    updateSpeedReadout(speed, acc);
    if(!state.route.length) return;
    const idxs=candidateIndices();
    idxs.forEach(idx=>{
      const station=state.route[idx];
      if(!station||station.lat==null||station.lon==null) return;
      const dist=haversine(lat,lon,station.lat,station.lon);
      station.lastSeenDistance=dist;
      evaluateGeofence(idx, dist);
      trackClosestApproach(idx);
    });
    processSpeedTriggers(speed);
    renderRouteCards();
    renderRouteMap();
    updateDelaySummary();
    saveActiveJourney(); // Auto-save journey state
  }

  const speedHistory=[];
  function estimateSpeedFromHistory(pos){
    const now=pos.timestamp||Date.now();
    speedHistory.push({
      lat:pos.coords.latitude,
      lon:pos.coords.longitude,
      t:now
    });
    while(speedHistory.length>10) speedHistory.shift();
    if(speedHistory.length<2) return null;
    const a=speedHistory[speedHistory.length-2];
    const b=speedHistory[speedHistory.length-1];
    const dt=(b.t-a.t)/1000;
    if(dt<=0) return null;
    const dist=haversine(a.lat,a.lon,b.lat,b.lon);
    return dist/dt;
  }

  function updateSpeedReadout(speed, accuracy){
    if(speed!=null){
      els.gpsSpeed.textContent=`${(speed*3.6).toFixed(1)} km/h`;
      if(speed<0.5){
        els.gpsExtra.textContent='Stillast√•ende (under 0,5 km/h)';
      }else if(speed<5){
        els.gpsExtra.textContent='L√•g fart ‚Äì m√∂jlig inbromsning eller avg√•ng';
      }else{
        els.gpsExtra.textContent='I r√∂relse';
      }
    }else{
      els.gpsSpeed.textContent='‚Äì';
      els.gpsExtra.textContent='Hastighet saknas i GPS-datat';
    }
    if(accuracy!=null){
      els.gpsAccuracy.textContent=`Noggrannhet: ¬±${Math.round(accuracy)} m`;
    }
  }

  function handlePositionError(err){
    updateGpsStatus(null, err);
    let msg = 'Kunde inte l√§sa GPS.';
    if(err){
      switch(err.code){
        case 1: msg = 'GPS-√•tkomst nekad ‚Äì aktivera platsbeh√∂righet'; break;
        case 2: msg = 'GPS-signal otillg√§nglig ‚Äì f√∂rs√∂k utomhus'; break;
        case 3: msg = 'GPS timeout ‚Äì f√∂rs√∂ker igen...'; break;
        default: msg = err.message || msg;
      }
    }
    showJourneyMessage(msg, true);
  }

  function updateGpsStatus(pos, error){
    if(pos){
      els.gpsStatusBadge.textContent='GPS aktiv';
      els.gpsStatusBadge.classList.add('live');
      els.gpsStatusBadge.classList.remove('warn');
      els.gpsStatusText.textContent='Signal mottagen';
      els.gpsCoords.textContent=`${pos.coords.latitude.toFixed(5)}, ${pos.coords.longitude.toFixed(5)}`;
      const ts=new Date(pos.timestamp||Date.now());
      els.gpsTimestamp.textContent=ts.toLocaleTimeString('sv-SE');
    }else if(error){
      els.gpsStatusBadge.textContent='GPS saknas';
      els.gpsStatusBadge.classList.add('warn');
      els.gpsStatusText.textContent=error.message||'Ingen GPS';
      els.gpsCoords.textContent='‚Äì';
      els.gpsTimestamp.textContent='‚Äì';
    }else{
      els.gpsStatusBadge.textContent='Ingen GPS √§nnu';
      els.gpsStatusBadge.classList.remove('warn','live');
      els.gpsStatusText.textContent='V√§ntar p√• position‚Ä¶';
      els.gpsCoords.textContent='‚Äì';
      els.gpsTimestamp.textContent='‚Äì';
    }
  }

  function candidateIndices(){
    if(!state.route.length) return [];
    const idxs=new Set();
    idxs.add(Math.max(0,state.lastReachedIndex-1));
    idxs.add(state.lastReachedIndex);
    if(state.nextIndex!=null) idxs.add(state.nextIndex);
    if(state.nextIndex!=null && state.nextIndex+1<state.route.length) idxs.add(state.nextIndex+1);
    return Array.from(idxs).filter(i=>i>=0 && i<state.route.length);
  }

  function evaluateGeofence(idx, distance){
    const station=state.route[idx];
    if(!station) return;
    const radius=station.radius||DEFAULT_RADIUS;
    const exitMargin=station.customRadius?0:EXTRA_MARGIN;
    const exitThreshold=radius+exitMargin;
    if(distance<=radius){
      if(!station.inZone){
        station.inZone=true;
        handleStationEntry(idx);
      }
    }else if(station.inZone && distance>exitThreshold){
      station.inZone=false;
      handleStationExit(idx);
    }
  }

  function trackClosestApproach(idx){
    const station=state.route[idx];
    if(!station||!station.shouldStop||!station.actualArrival||station.actualDeparture) return;
    if(!station.inZone) return;
    const dist=station.lastSeenDistance;
    if(dist==null) return;
    const pos=state.lastPosition;
    const now=new Date();
    if(station.closestDistance==null || dist<station.closestDistance-CLOSE_APPROACH_EPS){
      station.closestDistance=dist;
      station.closestTime=now;
      station.closestPosition=pos?{
        lat:pos.coords.latitude,
        lon:pos.coords.longitude,
        accuracy:pos.coords.accuracy||null
      }:null;
      if(station.needsArrivalRetiming){
        station.actualArrival=new Date(now);
        station.arrivalSource='gps';
        station.arrivalPosition=station.closestPosition;
      }
    }else if(station.needsArrivalRetiming && station.closestDistance!=null && dist>station.closestDistance+PASS_DISTANCE_MARGIN){
      // Markera passering ENDAST f√∂r stationer utan planerat stopp
      // F√∂r stationer med stopp: v√§nta p√• att anv√§ndaren stannar och avg√•r normalt
      if(!station.shouldStop){
        const speed = state.lastSpeed;
        const isMoving = typeof speed === 'number' && speed > SPEED_THRESHOLD_MS; // >5 km/h
        if(isMoving){
          markPassingDeparture(idx);
        }
      }
    }
  }

  function markPassingDeparture(idx){
    const station=state.route[idx];
    if(!station||station.actualDeparture) return;
    const pos=state.lastPosition;
    station.actualDeparture=new Date();
    station.departSource='gps-pass';
    station.departurePosition=pos?{
      lat:pos.coords.latitude,
      lon:pos.coords.longitude,
      accuracy:pos.coords.accuracy||null
    }:null;
    station.needsArrivalRetiming=false;
    station.reachedLowSpeed=false;
    station.departureProvisional=false;
    station.departureProvisionalAt=null;
    advanceAfterDeparture(idx);
  }

  function processSpeedTriggers(speed){
    if(typeof speed!=='number') return;
    const lastIdx=state.route.length?state.route.length-1:null;
    if(state.running && lastIdx!=null){
      const endStation=state.route[lastIdx];
      if(endStation && endStation.shouldStop && endStation.actualArrival && !endStation.actualDeparture && endStation.inZone && speed<=SPEED_THRESHOLD_MS){
        stopJourney(false, 'Slutstation registrerad ‚Äì stillast√•ende');
        return;
      }
    }
    const candidates=[];
    if(state.awaitingDepartureIndex!=null) candidates.push(state.awaitingDepartureIndex);
    if(state.departureProvisionalIdx!=null) candidates.push(state.departureProvisionalIdx);
    const seen=new Set();
    for(const idx of candidates){
      if(seen.has(idx)) continue;
      seen.add(idx);
      const station=state.route[idx];
      const allowNoArrivalAtStart = idx===0 && !station.actualArrival;
      if(!station||!station.shouldStop||(!station.actualArrival && !allowNoArrivalAtStart)) continue;
      const pos=state.lastPosition;
      const now=Date.now();
      if(station.actualDeparture && station.departureProvisional){
        const withinDist = station.lastSeenDistance!=null ? station.lastSeenDistance <= (station.radius||DEFAULT_RADIUS) + EXTRA_MARGIN*2 : true;
        const withinTime = !station.departureProvisionalAt || (now - station.departureProvisionalAt) <= DEPART_REVERT_WINDOW_MS;
        if(speed<=SPEED_THRESHOLD_MS && (withinDist || withinTime)){
          station.actualDeparture=null;
          station.departSource='';
          station.departurePosition=null;
          station.departureProvisional=false;
          station.departureProvisionalAt=null;
          state.awaitingDepartureIndex=idx;
          state.departureProvisionalIdx=null;
          station.reachedLowSpeed=true;
          state.lastReachedIndex=idx;
          state.nextIndex=idx+1<state.route.length?idx+1:null;
          updateNextStopUI();
          renderRouteCards();
          continue;
        }
        const farAway = station.lastSeenDistance!=null && station.lastSeenDistance > (station.radius||DEFAULT_RADIUS) + EXTRA_MARGIN*3;
        if(!withinTime || farAway){
          station.departureProvisional=false;
          station.departureProvisionalAt=null;
          if(state.departureProvisionalIdx===idx) state.departureProvisionalIdx=null;
        }
        continue;
      }
      if(!station.actualArrival && !allowNoArrivalAtStart) continue;
      if(station.actualDeparture) continue;
      if(station.needsArrivalRetiming && !station.inZone){
        station.needsArrivalRetiming=false;
      }
      if(station.needsArrivalRetiming && station.inZone && speed<=SPEED_THRESHOLD_MS){
        station.actualArrival=new Date();
        station.arrivalSource='gps';
        station.arrivalPosition=pos?{
          lat:pos.coords.latitude,
        lon:pos.coords.longitude,
        accuracy:pos.coords.accuracy||null
      }:null;
      station.needsArrivalRetiming=false;
      station.reachedLowSpeed=true;
    }else if(!station.reachedLowSpeed && speed<=SPEED_THRESHOLD_MS){
      station.reachedLowSpeed=true;
    }
    if(station.reachedLowSpeed && speed>=SPEED_THRESHOLD_MS){
      station.actualDeparture=new Date();
      station.departSource='gps';
      station.departurePosition=pos?{
        lat:pos.coords.latitude,
        lon:pos.coords.longitude,
        accuracy:pos.coords.accuracy||null
      }:null;
      station.departureProvisional=false;
      station.departureProvisionalAt=null;
      if(state.departureProvisionalIdx===idx) state.departureProvisionalIdx=null;
      advanceAfterDeparture(idx);
    }
    }
  }

  function handleStationEntry(idx){
    const station=state.route[idx];
    const pos=state.lastPosition;
    const posInfo=pos?{
      lat:pos.coords.latitude,
      lon:pos.coords.longitude,
      accuracy:pos.coords.accuracy||null
    }:null;
    const isStartStation = idx===0;
    if(isStartStation && !station.actualArrival && !station.actualDeparture){
      state.lastReachedIndex=idx;
      state.nextIndex=idx+1<state.route.length?idx+1:null;
      if(station.shouldStop){
        state.awaitingDepartureIndex=idx;
        const slowNow=typeof state.lastSpeed==='number' && state.lastSpeed<=SPEED_THRESHOLD_MS;
        station.reachedLowSpeed=slowNow;
        station.needsArrivalRetiming=false;
        station.closestDistance=station.lastSeenDistance!=null?station.lastSeenDistance:null;
        station.closestTime=new Date();
        station.closestPosition=posInfo;
      }
      updateNextStopUI();
      return;
    }
    if(!station.actualArrival){
      station.actualArrival=new Date();
      station.arrivalSource='gps';
      station.arrivalPosition=posInfo;
      state.lastReachedIndex=idx;
      state.nextIndex=idx+1<state.route.length?idx+1:null;
      vibrate([100, 50, 100]); // Double pulse for arrival
      playArrivalSound();
      updateNextStopUI();
    }
    if(!station.shouldStop){
      recordImmediatePass(idx);
    }else{
      state.awaitingDepartureIndex=idx;
      const slowNow=typeof state.lastSpeed==='number' && state.lastSpeed<=SPEED_THRESHOLD_MS;
      station.reachedLowSpeed=slowNow;
      station.needsArrivalRetiming=!slowNow;
      station.closestDistance=station.lastSeenDistance!=null?station.lastSeenDistance:null;
      station.closestTime=new Date();
      station.closestPosition=posInfo;
      if(idx===state.route.length-1){
        // sista station: inv√§nta stillast√•ende innan vi avslutar
        state.awaitingDepartureIndex=null;
      }
    }
  }

  function recordImmediatePass(idx){
    const station=state.route[idx];
    if(!station) return;
    station.passThrough=true;
    if(!station.actualDeparture){
      station.actualDeparture=new Date();
      station.departSource='gps-pass';
      station.departurePosition=station.arrivalPosition;
      station.departureProvisional=false;
      station.departureProvisionalAt=null;
    }
    advanceAfterDeparture(idx);
  }

  function handleStationExit(idx){
    const station=state.route[idx];
    if(!station.shouldStop) return;
    if(idx===state.route.length-1) return; // sista station: avslutas f√∂rst vid stillast√•ende
    const allowStartDeparture = idx===0 && !station.actualArrival;
    if((station.actualArrival || allowStartDeparture) && !station.actualDeparture){
      const pos=state.lastPosition;
      const speed=state.lastSpeed;
      const movingFast=typeof speed==='number' && speed>SPEED_THRESHOLD_MS;
      // Avg√•ng vid geofence-utg√•ng kr√§ver att vi faktiskt r√∂r oss
      // Om vi st√•r still (har stannat men inte b√∂rjat k√∂ra igen) √§r det troligen GPS-fluktuation
      // L√•t processSpeedTriggers hantera avg√•ng baserat p√• acceleration ist√§llet
      if(!movingFast){
        return;
      }
      station.actualDeparture=new Date();
      station.departSource='gps';
      station.departurePosition=pos?{
        lat:pos.coords.latitude,
        lon:pos.coords.longitude,
        accuracy:pos.coords.accuracy||null
      }:null;
      station.needsArrivalRetiming=false;
      station.reachedLowSpeed=true;
      station.departureProvisional=station.shouldStop && movingFast;
      station.departureProvisionalAt=station.departureProvisional?Date.now():null;
      if(station.departureProvisional){
        state.departureProvisionalIdx=idx;
      }
      advanceAfterDeparture(idx);
      if(station.departureProvisional){
        state.awaitingDepartureIndex=idx;
      }
    }
  }

  function advanceAfterDeparture(idx){
    state.lastReachedIndex=Math.max(state.lastReachedIndex, idx);
    state.nextIndex=idx+1<state.route.length?idx+1:null;
    if(state.awaitingDepartureIndex===idx){
      state.awaitingDepartureIndex=null;
    }
    const station=state.route[idx];
    if(station){
      station.needsArrivalRetiming=false;
      if(!station.departureProvisional){
        station.departureProvisionalAt=null;
        vibrate(200); // Single pulse for confirmed departure
        playDepartureSound();
      }
    }
    updateNextStopUI();
    if(idx===state.route.length-1){
      stopJourney(false, 'Slutstation klar');
    }else{
      scrollToNextStation();
    }
  }

  function scrollToNextStation(){
    if(state.nextIndex===null) return;
    setTimeout(()=>{
      const cards=els.cards.querySelectorAll('.card');
      const nextCard=cards[state.nextIndex];
      if(nextCard){
        nextCard.scrollIntoView({
          behavior:'smooth',
          block:'center'
        });
      }
    }, 500);
  }

  function updateNextStopUI(){
    if(state.nextIndex==null){
      els.nextStop.textContent='‚Äì';
      els.nextStopInfo.textContent='Alla stationer registrerade';
    }else{
      const st=state.route[state.nextIndex];
      els.nextStop.textContent=st.name;
      const dist=st.lastSeenDistance;
      els.nextStopInfo.textContent = dist!=null ? `‚âà${formatDistance(dist)} bort` : 'Ingen distansdata √§nnu';
    }
  }

  function renderRouteCards(){
    const cardsHtml=state.route.map((station,idx)=>{
      const arrival=station.actualArrival?formatTime(station.actualArrival):'‚Äì';
      const depart=station.actualDeparture?formatTime(station.actualDeparture):'‚Äì';
      const dist=station.lastSeenDistance!=null?formatDistance(station.lastSeenDistance):'‚Äì';
      const classes=['card'];
      if(state.nextIndex===idx) classes.push('active');
      if(expandedCards.has(idx)) classes.push('expanded');

      const schedArr = station.scheduledArrival ? formatTime(station.scheduledArrival) : null;
      const schedDep = station.scheduledDeparture ? formatTime(station.scheduledDeparture) : null;

      let arrDelayBadge = '';
      let depDelayBadge = '';

      if(station.actualArrival && station.scheduledArrival){
        const delayMin = Math.round((new Date(station.actualArrival) - new Date(station.scheduledArrival)) / 60000);
        const absDelay = Math.abs(delayMin);
        let badgeClass = '';
        let delayText = '';

        if(delayMin < -1){
          badgeClass = 'early';
          delayText = `${absDelay} min tidig`;
        } else if(delayMin > 1 && delayMin <= 5){
          badgeClass = 'late';
          delayText = `+${delayMin} min`;
        } else if(delayMin > 5){
          badgeClass = 'very-late';
          delayText = `+${delayMin} min`;
        } else {
          badgeClass = 'live';
          delayText = 'I tid';
        }

        arrDelayBadge = ` <span class="badge ${badgeClass}">${delayText}</span>`;
      }

      if(station.actualDeparture && station.scheduledDeparture){
        const delayMin = Math.round((new Date(station.actualDeparture) - new Date(station.scheduledDeparture)) / 60000);
        const absDelay = Math.abs(delayMin);
        let badgeClass = '';
        let delayText = '';

        if(delayMin < -1){
          badgeClass = 'early';
          delayText = `${absDelay} min tidig`;
        } else if(delayMin > 1 && delayMin <= 5){
          badgeClass = 'late';
          delayText = `+${delayMin} min`;
        } else if(delayMin > 5){
          badgeClass = 'very-late';
          delayText = `+${delayMin} min`;
        } else {
          badgeClass = 'live';
          delayText = 'I tid';
        }

        depDelayBadge = ` <span class="badge ${badgeClass}">${delayText}</span>`;
      }

      const isDone = station.actualArrival && station.actualDeparture;
      if(isDone) classes.push('done');
      const stopIcon = station.shouldStop ? '' : ' ‚è©';

      return `<div class="${classes.join(' ')}" data-idx="${idx}">
        <div class="card-header" data-action="toggle-expand" data-idx="${idx}">
          <div>
            <h3><span class="station-num">${station.order}</span>${station.name}${stopIcon}</h3>
            <div class="card-times">
              <span class="arr"><strong>${arrival}</strong>${arrDelayBadge}</span>
              <span class="dep"><strong>${depart}</strong>${depDelayBadge}</span>
            </div>
          </div>
          <div style="display:flex;align-items:center;gap:.4rem">
            <span class="badge dist">${dist}</span>
            <span class="card-toggle">‚ñº</span>
          </div>
        </div>
        <div class="card-expand">
          <div class="card-expand-inner">
            ${schedArr ? `<p class="scheduled">Ank schema: ${schedArr}</p>` : ''}
            ${schedDep ? `<p class="scheduled">Avg schema: ${schedDep}</p>` : ''}
            <p class="meta">${Math.round(station.radius)} m radie ‚Ä¢ ${station.lat!=null?station.lat.toFixed(4):'‚Äì'}, ${station.lon!=null?station.lon.toFixed(4):'‚Äì'}</p>
            <div class="control-row">
              <label><input type="checkbox" data-action="toggle-stop" data-idx="${idx}" ${station.shouldStop?'checked':''}> Planerat stopp</label>
            </div>
            <div class="control-row">
              <label><input type="checkbox" data-action="exclude-run" data-idx="${idx}" ${station.excludeInboundRun?'checked':''}> Exkludera g√•ngtid</label>
            </div>
            <div class="bar card-actions">
              <button class="ghost sm" data-action="arrive" data-idx="${idx}">‚Üì Ankomst</button>
              <button class="ghost sm" data-action="depart" data-idx="${idx}">‚Üë Avg√•ng</button>
              <button class="ghost sm" data-action="update-pos" data-idx="${idx}">üìç Uppdatera pos</button>
            </div>
            <textarea class="station-note" data-action="station-note" data-idx="${idx}" placeholder="Anteckning (t.ex. signal, m√∂te...)">${escapeHtml(station.notes||'')}</textarea>
          </div>
        </div>
      </div>`;
    }).join('');
    els.cards.innerHTML=cardsHtml;
    updateNextStopUI();
  }

  function formatTime(dt){
    return new Date(dt).toLocaleTimeString('sv-SE',{hour:'2-digit',minute:'2-digit',second:'2-digit'});
  }

  function formatDistance(meters){
    if(meters>1000) return (meters/1000).toFixed(2)+' km';
    return Math.round(meters)+' m';
  }

  function handleCardButton(ev){
    // Handle card header toggle
    const header=ev.target.closest('[data-action="toggle-expand"]');
    if(header){
      const card=header.closest('.card');
      if(card){
        const idx=parseInt(card.dataset.idx,10);
        card.classList.toggle('expanded');
        if(card.classList.contains('expanded')){
          expandedCards.add(idx);
        }else{
          expandedCards.delete(idx);
        }
      }
      return;
    }
    const btn=ev.target.closest('button[data-action]');
    if(!btn) return;
    const idx=parseInt(btn.dataset.idx,10);
    if(Number.isNaN(idx) || !state.route[idx]) return;
    if(btn.dataset.action==='arrive'){
      manualArrival(idx);
    }else if(btn.dataset.action==='depart'){
      manualDeparture(idx);
    }else if(btn.dataset.action==='update-pos'){
      const station=state.route[idx];
      if(!station) return;
      calibrateWithCurrentPosition(station.name, true);
    }
  }

  function handleCardChange(ev){
    const target=ev.target;
    const action=target.dataset.action;
    if(action==='toggle-stop'){
      const idx=parseInt(target.dataset.idx,10);
      if(!state.route[idx]) return;
      state.route[idx].shouldStop=target.checked;
      if(!target.checked && state.awaitingDepartureIndex===idx){
        state.awaitingDepartureIndex=null;
      }
      renderRouteCards();
    }else if(action==='exclude-run'){
      const idx=parseInt(target.dataset.idx,10);
      if(!state.route[idx]) return;
      state.route[idx].excludeInboundRun=target.checked;
    }
  }

  function manualArrival(idx){
    const station=state.route[idx];
    if(!station) return;
    station.actualArrival=new Date();
    station.arrivalSource='manual';
    vibrate([100, 50, 100]); // Double pulse for arrival
    playArrivalSound();
    station.arrivalPosition=state.lastPosition?{
      lat:state.lastPosition.coords.latitude,
      lon:state.lastPosition.coords.longitude,
      accuracy:state.lastPosition.coords.accuracy||null
    }:null;
    station.inZone=true;
    station.needsArrivalRetiming=false;
    station.reachedLowSpeed=true;
    state.lastReachedIndex=idx;
    state.nextIndex=idx+1<state.route.length?idx+1:null;
    if(station.shouldStop){
      state.awaitingDepartureIndex=idx;
    }
    renderRouteCards();
  }

  function manualDeparture(idx){
    const station=state.route[idx];
    if(!station) return;
    station.actualDeparture=new Date();
    station.departSource='manual';
    vibrate(200); // Single pulse for departure
    playDepartureSound();
    station.departurePosition=state.lastPosition?{
      lat:state.lastPosition.coords.latitude,
      lon:state.lastPosition.coords.longitude,
      accuracy:state.lastPosition.coords.accuracy||null
    }:null;
    station.needsArrivalRetiming=false;
    station.reachedLowSpeed=true;
    station.departureProvisional=false;
    station.departureProvisionalAt=null;
    if(state.departureProvisionalIdx===idx) state.departureProvisionalIdx=null;
    advanceAfterDeparture(idx);
    renderRouteCards();
  }

  function stopJourney(aborted, reason){
    if(!state.route.length) return;
    if(state.watchId!==null){
      navigator.geolocation.clearWatch(state.watchId);
      state.watchId=null;
    }
    state.running=false;
    state.aborted=!!aborted;
    state.autoReason=reason||'';
    state.departureProvisionalIdx=null;
    clearActiveJourney(); // Clear saved journey since it's now complete
    document.getElementById('delaySummary').style.display='none';
    els.journeyMsg.textContent=reason|| (aborted?'Resan avslutad':'Resan sparad');
    els.journeyMsg.style.display='inline-block';
    const logEntry=saveLog(aborted);
    renderReport(logEntry);
    els.journey.style.display='none';
    els.report.style.display='block';
    els.setup.style.display='block';
  }

  function renderReport(logEntry){
    if(!logEntry){
      els.reportHTML.innerHTML='<p>Ingen data att visa.</p>';
      return;
    }
    const rows=logEntry.stops.map((st,idx)=>{
      const dwell=st.actualArrival&&st.actualDeparture?((new Date(st.actualDeparture)-new Date(st.actualArrival))/60000).toFixed(1)+' min':'‚Äì';

      let arrDelay = '‚Äì';
      if(st.actualArrival && st.scheduledArrival){
        const delayMin = Math.round((new Date(st.actualArrival) - new Date(st.scheduledArrival)) / 60000);
        if(delayMin < -1){
          arrDelay = `${Math.abs(delayMin)} min tidig`;
        } else if(delayMin > 1){
          arrDelay = `+${delayMin} min`;
        } else {
          arrDelay = 'I tid';
        }
      }

      let depDelay = '‚Äì';
      if(st.actualDeparture && st.scheduledDeparture){
        const delayMin = Math.round((new Date(st.actualDeparture) - new Date(st.scheduledDeparture)) / 60000);
        if(delayMin < -1){
          depDelay = `${Math.abs(delayMin)} min tidig`;
        } else if(delayMin > 1){
          depDelay = `+${delayMin} min`;
        } else {
          depDelay = 'I tid';
        }
      }

      return `<tr>
        <td>${idx+1}</td>
        <td>${st.name}</td>
        <td>${st.actualArrival?formatTime(st.actualArrival):'‚Äì'}${st.scheduledArrival?`<br><span class="meta">Schema: ${formatTime(st.scheduledArrival)}</span>`:''}</td>
        <td>${st.actualDeparture?formatTime(st.actualDeparture):'‚Äì'}${st.scheduledDeparture?`<br><span class="meta">Schema: ${formatTime(st.scheduledDeparture)}</span>`:''}</td>
        <td>${dwell}</td>
        <td>${arrDelay}</td>
        <td>${depDelay}</td>
      </tr>`;
    }).join('');
    els.reportHTML.innerHTML=`
      <p><strong>T√•g:</strong> ${logEntry.trainNumber||'‚Äì'} ‚Ä¢ <strong>Fordon:</strong> ${logEntry.vehicleType||'‚Äì'} ‚Ä¢ <strong>Str√§cka:</strong> ${logEntry.startStation} ‚Üí ${logEntry.endStation}</p>
      <p><strong>Start:</strong> ${logEntry.startedAt?new Date(logEntry.startedAt).toLocaleString('sv-SE'):'‚Äì'} ‚Ä¢ <strong>Slut:</strong> ${logEntry.finishedAt?new Date(logEntry.finishedAt).toLocaleString('sv-SE'):'‚Äì'}</p>
      ${logEntry.notes?`<p><strong>Anteckningar:</strong> ${escapeHtml(logEntry.notes)}</p>`:''}
      <div class="table-wrap">
        <table>
          <thead>
            <tr><th>#</th><th>Station</th><th>Ankomst</th><th>Avg√•ng</th><th>Uppeh√•ll</th><th>F√∂rseningank</th><th>F√∂rseningavg</th></tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      </div>
      <p>${state.aborted?'Status: Avbruten':'Status: Klar'}${state.autoReason?` ‚Äì ${state.autoReason}`:''}</p>
    `;
  }

  // === Statistics ===
  function showStatistics(){
    document.getElementById('setup').style.display = 'none';
    document.getElementById('journey').style.display = 'none';
    document.getElementById('report').style.display = 'none';
    document.getElementById('statistics').style.display = 'block';
    populateStatsFilters();
    renderStatistics();
  }

  function hideStatistics(){
    document.getElementById('statistics').style.display = 'none';
    document.getElementById('setup').style.display = 'block';
  }

  function populateStatsFilters(){
    const logs = loadLogs();
    const vehicles = new Set();
    const routes = new Set();

    logs.forEach(log => {
      if(log.vehicleType) vehicles.add(log.vehicleType);
      if(log.startStation && log.endStation){
        routes.add(`${log.startStation} ‚Üí ${log.endStation}`);
      }
    });

    const vehicleSelect = document.getElementById('statsVehicleFilter');
    const routeSelect = document.getElementById('statsRouteFilter');

    vehicleSelect.innerHTML = '<option value="">Alla fordon</option>' +
      Array.from(vehicles).sort().map(v => `<option value="${escapeHtml(v)}">${escapeHtml(v)}</option>`).join('');

    routeSelect.innerHTML = '<option value="">Alla str√§ckor</option>' +
      Array.from(routes).sort().map(r => `<option value="${escapeHtml(r)}">${escapeHtml(r)}</option>`).join('');
  }

  function renderStatistics(){
    const logs = loadLogs();
    const vehicleFilter = document.getElementById('statsVehicleFilter').value;
    const routeFilter = document.getElementById('statsRouteFilter').value;

    // Filter logs
    const filtered = logs.filter(log => {
      if(vehicleFilter && log.vehicleType !== vehicleFilter) return false;
      if(routeFilter){
        const logRoute = `${log.startStation} ‚Üí ${log.endStation}`;
        if(logRoute !== routeFilter) return false;
      }
      return !log.aborted;
    });

    if(filtered.length === 0){
      document.getElementById('statsContent').innerHTML = '<p style="color:var(--mut)">Inga k√∂rningar matchar filtret.</p>';
      return;
    }

    // Calculate segment statistics
    const segments = {};
    filtered.forEach(log => {
      if(!log.stops || log.stops.length < 2) return;

      for(let i=0; i<log.stops.length-1; i++){
        const from = log.stops[i];
        const to = log.stops[i+1];
        if(!from.actualDeparture || !to.actualArrival) continue;
        if(from.excludeInboundRun || to.excludeInboundRun) continue;

        const key = `${from.name} ‚Üí ${to.name}`;
        const runTime = (new Date(to.actualArrival) - new Date(from.actualDeparture)) / 1000; // seconds

        if(runTime <= 0 || runTime > 7200) continue; // Skip invalid times (>2h)

        if(!segments[key]){
          segments[key] = { times: [], best: Infinity, worst: 0 };
        }
        segments[key].times.push(runTime);
        segments[key].best = Math.min(segments[key].best, runTime);
        segments[key].worst = Math.max(segments[key].worst, runTime);
      }
    });

    const segmentKeys = Object.keys(segments).sort();
    if(segmentKeys.length === 0){
      document.getElementById('statsContent').innerHTML = '<p style="color:var(--mut)">Inga g√•ngtider registrerade.</p>';
      return;
    }

    // Find global max for bar scaling
    const globalMax = Math.max(...segmentKeys.map(k => segments[k].worst));

    let html = `<p style="font-size:.8rem;color:var(--ink-dim);margin-bottom:.75rem">${filtered.length} k√∂rningar analyserade</p>`;

    segmentKeys.forEach(key => {
      const seg = segments[key];
      const avg = seg.times.reduce((a,b)=>a+b,0) / seg.times.length;
      const barWidth = (avg / globalMax * 100).toFixed(1);

      html += `
        <div class="stats-card">
          <h4>${escapeHtml(key)}</h4>
          <div class="stats-row">
            <span class="stats-label">K√∂rningar</span>
            <span class="stats-value">${seg.times.length}</span>
          </div>
          <div class="stats-row">
            <span class="stats-label">Medel</span>
            <span class="stats-value">${formatDuration(avg)}</span>
          </div>
          <div class="stats-row">
            <span class="stats-label">B√§sta</span>
            <span class="stats-value">${formatDuration(seg.best)}</span>
          </div>
          <div class="stats-row">
            <span class="stats-label">S√§msta</span>
            <span class="stats-value">${formatDuration(seg.worst)}</span>
          </div>
          <div class="stats-bar"><div class="stats-bar-fill" style="width:${barWidth}%"></div></div>
        </div>
      `;
    });

    document.getElementById('statsContent').innerHTML = html;
  }

  function formatDuration(seconds){
    const m = Math.floor(seconds / 60);
    const s = Math.round(seconds % 60);
    return `${m}:${s.toString().padStart(2,'0')}`;
  }

  // === Route Map ===
  function renderRouteMap(){
    const container = document.getElementById('routeMap');
    if(!container || !state.route || state.route.length < 2) return;

    const stations = state.route.filter(s => s.lat != null && s.lon != null);
    if(stations.length < 2) return;

    // Calculate bounds
    const lats = stations.map(s => s.lat);
    const lons = stations.map(s => s.lon);
    const minLat = Math.min(...lats);
    const maxLat = Math.max(...lats);
    const minLon = Math.min(...lons);
    const maxLon = Math.max(...lons);

    const padding = 20;
    const width = container.clientWidth || 300;
    const height = container.clientHeight || 150;

    // Scale coordinates to SVG
    const latRange = maxLat - minLat || 0.01;
    const lonRange = maxLon - minLon || 0.01;
    const scale = Math.min((width - padding*2) / lonRange, (height - padding*2) / latRange);

    function toX(lon){ return padding + (lon - minLon) * scale; }
    function toY(lat){ return height - padding - (lat - minLat) * scale; }

    // Build SVG
    let svg = `<svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">`;

    // Route line
    const pathPoints = stations.map(s => `${toX(s.lon)},${toY(s.lat)}`).join(' ');
    svg += `<polyline points="${pathPoints}" fill="none" stroke="var(--b-light)" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>`;

    // Stations
    stations.forEach((st, idx) => {
      const x = toX(st.lon);
      const y = toY(st.lat);
      const isDone = st.actualArrival && st.actualDeparture;
      const isArrived = st.actualArrival && !st.actualDeparture;
      const isStartingHere = idx === 0 && !st.actualDeparture; // At start, haven't left yet

      // Only show next station as blue if we've departed from previous station
      const prevStation = idx > 0 ? state.route[idx-1] : null;
      const prevDeparted = prevStation ? prevStation.actualDeparture : false;
      const isNextEnRoute = state.nextIndex === idx && prevDeparted;

      let color = 'var(--mut)'; // gray = not visited
      if(isDone) color = 'var(--pri)'; // green = completed
      else if(isArrived || isStartingHere) color = 'var(--sec)'; // orange = you're here
      else if(isNextEnRoute) color = 'var(--blue)'; // blue = next (only when traveling)

      const isCurrent = isArrived || isStartingHere;
      const r = isCurrent ? 8 : 6;
      svg += `<g class="map-station">
        <circle cx="${x}" cy="${y}" r="${r}" fill="${color}" stroke="var(--bg)" stroke-width="2"/>
        ${idx === 0 || idx === stations.length-1 ?
          `<text x="${x}" y="${y + r + 12}" text-anchor="middle" fill="var(--ink-dim)" font-size="10">${escapeHtml(st.name.substring(0,10))}</text>` : ''
        }
      </g>`;
    });

    // Current position marker
    if(state.lastPosition){
      const posLat = state.lastPosition.coords.latitude;
      const posLon = state.lastPosition.coords.longitude;
      // Only show if within reasonable bounds
      if(posLat >= minLat - latRange*0.5 && posLat <= maxLat + latRange*0.5 &&
         posLon >= minLon - lonRange*0.5 && posLon <= maxLon + lonRange*0.5){
        const px = toX(posLon);
        const py = toY(posLat);
        svg += `<circle class="map-pos-marker" cx="${px}" cy="${py}" r="5" fill="var(--pri)">
          <animate attributeName="r" values="5;8;5" dur="2s" repeatCount="indefinite"/>
          <animate attributeName="opacity" values="1;0.6;1" dur="2s" repeatCount="indefinite"/>
        </circle>`;
      }
    }

    svg += '</svg>';
    container.innerHTML = svg;
  }

  // === Station Notes ===
  function handleCardInput(ev){
    const target = ev.target;
    if(target.dataset.action === 'station-note'){
      const idx = parseInt(target.dataset.idx, 10);
      if(state.route[idx]){
        state.route[idx].notes = target.value;
        saveActiveJourney();
      }
    }
  }

  // === Delay Summary ===
  function updateDelaySummary(){
    const el = document.getElementById('delaySummary');
    if(!el || !state.running) {
      if(el) el.style.display = 'none';
      return;
    }

    // Find latest station with actual arrival and scheduled arrival
    let latestDelay = null;
    for(let i = state.route.length - 1; i >= 0; i--){
      const st = state.route[i];
      if(st.actualArrival && st.scheduledArrival){
        latestDelay = Math.round((new Date(st.actualArrival) - new Date(st.scheduledArrival)) / 60000);
        break;
      }
    }

    if(latestDelay === null){
      el.style.display = 'none';
      return;
    }

    el.style.display = 'inline-flex';
    el.className = 'badge';
    if(latestDelay <= 1 && latestDelay >= -1){
      el.textContent = 'I tid';
      el.classList.add('on-time');
    } else if(latestDelay > 1 && latestDelay <= 5){
      el.textContent = `+${latestDelay} min`;
      el.classList.add('late');
    } else if(latestDelay > 5){
      el.textContent = `+${latestDelay} min`;
      el.classList.add('very-late');
    } else {
      el.textContent = `${latestDelay} min`;
      el.classList.add('on-time');
    }
  }

  function saveLog(aborted){
    const logs=loadLogs();
    const entry={
      id:Date.now().toString(36),
      trainNumber:state.trainNumber,
      vehicleType:state.vehicleType,
      startStation:state.route[0]?.name||'',
      endStation:state.route[state.route.length-1]?.name||'',
      startedAt:state.startedAt,
      finishedAt:new Date(),
      aborted:!!aborted,
      notes:state.notes,
      stops:state.route.map(st=>({
        name:st.name,
        actualArrival:st.actualArrival,
        actualDeparture:st.actualDeparture,
        scheduledArrival:st.scheduledArrival,
        scheduledDeparture:st.scheduledDeparture,
        arrivalSource:st.arrivalSource,
        departSource:st.departSource,
        shouldStop:st.shouldStop,
        excludeInboundRun:!!st.excludeInboundRun,
        notes:st.notes||''
      }))
    };
    logs.push(entry);
    try{
      localStorage.setItem(STORAGE_KEY_LOGS, JSON.stringify(logs));
    }catch(e){}
    updateLogCount();

    if(entry.trainNumber && entry.startStation && entry.endStation) {
      updateRouteHistory(entry.trainNumber, entry.startStation, entry.endStation);
    }

    return entry;
  }

  function loadLogs(){
    try{
      const raw=localStorage.getItem(STORAGE_KEY_LOGS);
      if(!raw) return [];
      const parsed=JSON.parse(raw);
      if(!Array.isArray(parsed)) return [];
      return parsed.map(normalizeLogEntry).filter(Boolean);
    }catch(e){
      return [];
    }
  }

  function loadRouteHistory(){
    try{
      const raw=localStorage.getItem(STORAGE_KEY_ROUTE_HISTORY);
      if(!raw) return {};
      const parsed=JSON.parse(raw);
      return parsed && typeof parsed==='object' ? parsed : {};
    }catch(e){
      console.error('Kunde ej ladda rutt-historik:', e);
      return {};
    }
  }

  function saveRouteHistory(history){
    try{
      localStorage.setItem(STORAGE_KEY_ROUTE_HISTORY, JSON.stringify(history));
    }catch(e){
      console.error('Kunde ej spara rutt-historik:', e);
    }
  }

  function updateRouteHistory(trainNumber, startStation, endStation){
    if(!trainNumber || !startStation || !endStation) return;

    const history = loadRouteHistory();
    if(!history[trainNumber]) {
      history[trainNumber] = [];
    }

    const now = new Date();
    history[trainNumber].push({
      start: startStation,
      end: endStation,
      timestamp: now.toISOString(),
      hour: now.getHours(),
      minute: now.getMinutes()
    });

    if(history[trainNumber].length > 100) {
      history[trainNumber] = history[trainNumber].slice(-100);
    }

    saveRouteHistory(history);
  }

  function analyzeRouteHistory(trainNumber, currentHour){
    if(!trainNumber) return null;

    const history = loadRouteHistory();
    const routes = history[trainNumber];

    if(!routes || routes.length === 0) return null;

    const routeCounts = {};
    const TIME_WINDOW = 2;

    routes.forEach(r => {
      const key = `${r.start}|${r.end}`;
      if(!routeCounts[key]) {
        routeCounts[key] = { start: r.start, end: r.end, count: 0, timeMatch: 0 };
      }
      routeCounts[key].count++;

      if(currentHour !== undefined && r.hour !== undefined) {
        const timeDiff = Math.abs(r.hour - currentHour);
        if(timeDiff <= TIME_WINDOW) {
          routeCounts[key].timeMatch++;
        }
      }
    });

    const sorted = Object.values(routeCounts).sort((a, b) => {
      if(currentHour !== undefined && (a.timeMatch > 0 || b.timeMatch > 0)) {
        if(a.timeMatch !== b.timeMatch) return b.timeMatch - a.timeMatch;
      }
      return b.count - a.count;
    });

    return sorted[0] || null;
  }

  async function handleTrainNumberInput(e){
    const trainNumber = e.target.value.trim();

    if(!trainNumber || trainNumber.length < 2) {
      document.getElementById('routeSuggestion').style.display='none';
      currentSuggestion = null;
      return;
    }

    setTimeout(async () => {
      const currentTime = new Date();
      const currentHour = currentTime.getHours();
      const currentMinute = currentTime.getMinutes();

      let suggestion = null;
      let suggestionSource = '';

      const timetableResult = await fetchTimetable(trainNumber, currentTime);

      if(timetableResult.success && timetableResult.timetable) {
        const nearestStation = await findNearestStation();
        const timeBasedRoute = findCurrentRouteSegment(
          timetableResult.timetable,
          nearestStation,
          currentHour,
          currentMinute
        );

        if(timeBasedRoute) {
          suggestion = {
            start: timeBasedRoute.start,
            end: timeBasedRoute.end,
            count: 0
          };
          suggestionSource = `GPS + tidtabell (${timeBasedRoute.startTime})`;
        }
      }

      if(!suggestion) {
        const historySuggestion = analyzeRouteHistory(trainNumber, currentHour);
        if(historySuggestion && historySuggestion.count >= 1) {
          suggestion = historySuggestion;
          suggestionSource = historySuggestion.count === 1
            ? '1 tidigare k√∂rning'
            : `${historySuggestion.count} tidigare k√∂rningar`;
        }
      }

      if(suggestion) {
        currentSuggestion = suggestion;
        const text = `T√•g ${trainNumber}: ${suggestion.start} ‚Üí ${suggestion.end}`;

        document.getElementById('suggestionText').innerHTML =
          `<strong style="font-size:1.1rem">${text}</strong><br><span style="color:#718096;font-size:.9rem">${suggestionSource}</span>`;
        document.getElementById('routeSuggestion').style.display='block';
      } else {
        document.getElementById('routeSuggestion').style.display='none';
        currentSuggestion = null;
      }
    }, 300);
  }

  function acceptSuggestion(){
    if(!currentSuggestion) return;

    // Find stations in cache
    const startStation = allStationsCache.find(s => s.name === currentSuggestion.start);
    const endStation = allStationsCache.find(s => s.name === currentSuggestion.end);

    if(startStation){
      els.startInput.value = startStation.name;
      selectedStartStation = startStation;
    }
    if(endStation){
      els.endInput.value = endStation.name;
      selectedEndStation = endStation;
    }

    document.getElementById('routeSuggestion').style.display='none';

    const msg = document.createElement('div');
    msg.style.cssText = 'position:fixed;top:80px;left:50%;transform:translateX(-50%);background:#48bb78;color:white;padding:.8rem 1.5rem;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.15);z-index:1000;font-weight:600;';
    msg.textContent = `‚úì Rutt vald: ${currentSuggestion.start} ‚Üí ${currentSuggestion.end}`;
    document.body.appendChild(msg);
    setTimeout(() => msg.remove(), 2500);
  }

  async function findNearestStation(){
    return new Promise((resolve) => {
      if(!navigator.geolocation) {
        resolve(null);
        return;
      }

      navigator.geolocation.getCurrentPosition(
        (position) => {
          const userLat = position.coords.latitude;
          const userLon = position.coords.longitude;

          let nearest = null;
          let minDistance = Infinity;

          // Use allStationsCache instead of stationCatalog
          allStationsCache.forEach(station => {
            if(!station.lat || !station.lon) return;
            const dist = haversine(userLat, userLon, station.lat, station.lon);
            if(dist < minDistance) {
              minDistance = dist;
              nearest = station.name;
            }
          });

          resolve(nearest);
        },
        (error) => {
          resolve(null);
        },
        { timeout: 5000, maximumAge: 60000 }
      );
    });
  }

  function findCurrentRouteSegment(timetable, nearestStation, currentHour, currentMinute){
    if(!timetable || !nearestStation) return null;

    const currentTimeMinutes = currentHour * 60 + currentMinute;
    const BEFORE_MARGIN = 30;
    const AFTER_MARGIN = 15;

    // Find signature from allStationsCache
    const nearestStationData = allStationsCache.find(s => s.name === nearestStation);
    const nearestSig = nearestStationData ? nearestStationData.sig : null;
    if(!nearestSig) return null;

    const stationTimes = timetable[nearestSig];
    if(!stationTimes) return null;

    const departureTime = stationTimes.departure;
    if(!departureTime) return null;

    const depHour = departureTime.getHours();
    const depMinute = departureTime.getMinutes();
    const depTimeMinutes = depHour * 60 + depMinute;

    const timeDiff = currentTimeMinutes - depTimeMinutes;

    if(timeDiff >= -BEFORE_MARGIN && timeDiff <= AFTER_MARGIN) {
      const sortedStations = Object.keys(timetable)
        .map(sig => {
          const info = timetable[sig];
          const time = info.departure || info.arrival;
          return { sig, time, info };
        })
        .filter(s => s.time)
        .sort((a, b) => a.time - b.time);

      const currentStationIndex = sortedStations.findIndex(s => s.sig === nearestSig);
      if(currentStationIndex === -1) return null;

      const startStation = nearestStation;

      let endStation = null;
      for(let i = sortedStations.length - 1; i > currentStationIndex; i--) {
        const sig = sortedStations[i].sig;
        // Find station name from allStationsCache by signature
        const stationData = allStationsCache.find(s => s.sig === sig);
        if(stationData) {
          endStation = stationData.name;
          break;
        }
      }

      if(!endStation) return null;

      return {
        start: startStation,
        end: endStation,
        startTime: `${String(depHour).padStart(2, '0')}:${String(depMinute).padStart(2, '0')}`
      };
    }

    return null;
  }

  async function syncLogs(){
    if(!('showOpenFilePicker' in window) || !('showSaveFilePicker' in window)){
      alert('Din webbl√§sare saknar fil√•tkomst-API. Anv√§nd Chrome/Edge via https f√∂r att synka eller exportera ist√§llet.');
      return;
    }
    try{
      let handle=null;
      try{
        const result=await window.showOpenFilePicker({
          types:[{description:'JSON-loggar',accept:{'application/json':['.json']}}],
          excludeAcceptAllOption:false,
          multiple:false
        });
        if(result && result[0]) handle=result[0];
      }catch(e){
        if(e && e.name==='AbortError'){
          showHeaderStatus('Synk avbruten ‚Äì ingen fil vald.', true);
          return;
        }
        throw e;
      }
      if(!handle){
        showHeaderStatus('Hittade ingen loggfil. Exportera f√∂rst f√∂r att skapa en fil.', true);
        return;
      }
      const file=await handle.getFile();
      const text=await file.text();
      const fileLogs=(()=>{
        try{ return JSON.parse(text||'[]'); }
        catch(e){ return []; }
      })();
      const incomingRaw=Array.isArray(fileLogs)?fileLogs:(fileLogs?[fileLogs]:[]);
      const normalizedIncoming=incomingRaw.map(normalizeLogEntry).filter(Boolean);
      const existing=loadLogs();
      const merged=dedupeLogs(existing.concat(normalizedIncoming));
      const added=Math.max(merged.length - existing.length, 0);
      const ignored=Math.max(incomingRaw.length - normalizedIncoming.length, 0);
      const writable=await handle.createWritable();
      await writable.write(JSON.stringify(merged,null,2));
      await writable.close();
      try{
        localStorage.setItem(STORAGE_KEY_LOGS, JSON.stringify(merged));
      }catch(e){}
      updateLogCount();
      const message = normalizedIncoming.length
        ? `Synk klar: +${added} / ignorerade ${ignored}`
        : 'Ingen giltig logg hittades i filen.';
      showHeaderStatus(message, !normalizedIncoming.length);
    }catch(err){
      const msg = err && (err.message || err.name) ? `${err.name||''} ${err.message||''}`.trim() : 'Ok√§nt fel';
      showHeaderStatus(`Synk misslyckades: ${msg}`, true);
      console.error(err);
    }
  }

  function exportLogs(){
    const logs=loadLogs();
    const blob=new Blob([JSON.stringify(logs,null,2)],{type:'application/json'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url;
    a.download='railtimer_logs.json';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function exportLogsCSV(){
    const logs=loadLogs();
    if(!logs.length){
      showHeaderStatus('Inga loggar att exportera.', true);
      return;
    }
    const rows=[['Datum','T√•g','Fordon','Fr√•n','Till','Station','Ordning','Ankomst','Avg√•ng','Schema Ank','Schema Avg','F√∂rsenad (min)','K√§lla']];
    logs.forEach(log=>{
      const logDate=log.startedAt?new Date(log.startedAt).toLocaleDateString('sv-SE'):'';
      const trainNum=log.trainNumber||'';
      const vehicleType=log.vehicleType||'';
      const fromSt=log.route&&log.route[0]?log.route[0].name:'';
      const toSt=log.route&&log.route.length?log.route[log.route.length-1].name:'';
      (log.route||[]).forEach(st=>{
        const arr=st.actualArrival?new Date(st.actualArrival).toLocaleTimeString('sv-SE'):'';
        const dep=st.actualDeparture?new Date(st.actualDeparture).toLocaleTimeString('sv-SE'):'';
        const schArr=st.scheduledArrival?new Date(st.scheduledArrival).toLocaleTimeString('sv-SE'):'';
        const schDep=st.scheduledDeparture?new Date(st.scheduledDeparture).toLocaleTimeString('sv-SE'):'';
        let delay='';
        if(st.actualArrival&&st.scheduledArrival){
          delay=Math.round((new Date(st.actualArrival)-new Date(st.scheduledArrival))/60000);
        }
        const source=st.arrivalSource||'';
        rows.push([logDate,trainNum,vehicleType,fromSt,toSt,st.name,st.order||'',arr,dep,schArr,schDep,delay,source]);
      });
    });
    const csv=rows.map(r=>r.map(c=>'"'+(c+'').replace(/"/g,'""')+'"').join(';')).join('\n');
    const bom='\uFEFF';
    const blob=new Blob([bom+csv],{type:'text/csv;charset=utf-8'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url;
    a.download='railtimer_logs.csv';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  async function saveLogsToFile(){
    const localLogs=loadLogs();
    if(!('showOpenFilePicker' in window)){
      showHeaderStatus('Webbl√§saren saknar fil-API. Anv√§nd Exportera ist√§llet.', true);
      return;
    }
    try{
      let handle=null;
      try{
        const result=await window.showOpenFilePicker({
          types:[{description:'JSON-loggar',accept:{'application/json':['.json']}}],
          excludeAcceptAllOption:false,
          multiple:false
        });
        if(result && result[0]) handle=result[0];
      }catch(e){
        if(e && e.name==='AbortError'){
          showHeaderStatus('Sparande avbr√∂ts.', true);
          return;
        }
        throw e;
      }
      if(!handle){
        showHeaderStatus('Ingen fil vald.', true);
        return;
      }
      let existingText='';
      let incomingArray=[];
      try{
        const file=await handle.getFile();
        existingText=await file.text();
        const parsed=(()=>{
          try{ return JSON.parse(existingText||'[]'); }
          catch(e){ return null; }
        })();
        if(parsed===null){
          showHeaderStatus('Kunde inte l√§sa filen ‚Äì sparar inte.', true);
          return;
        }
        incomingArray=Array.isArray(parsed)?parsed:(parsed?[parsed]:[]);
      }catch(e){
        incomingArray=[];
      }
      const normalizedIncoming=incomingArray.map(normalizeLogEntry).filter(Boolean);
      const merged=dedupeLogs(localLogs.concat(normalizedIncoming));
      if(!merged.length){
        showHeaderStatus('Inga loggar att spara ‚Äì ingen skrivning gjordes.', true);
        return;
      }
      const writable=await handle.createWritable();
      await writable.write(JSON.stringify(merged,null,2));
      await writable.close();
      try{
        localStorage.setItem(STORAGE_KEY_LOGS, JSON.stringify(merged));
      }catch(e){}
      updateLogCount();
      showHeaderStatus(`Sparat & synkat: ${merged.length} loggar`, false);
    }catch(err){
      if(err && err.name==='AbortError'){
        showHeaderStatus('Sparande avbr√∂ts.', true);
        return;
      }
      const msg=err && (err.message||err.name)?`${err.name||''} ${err.message||''}`.trim():'Kunde inte spara';
      showHeaderStatus(msg, true);
    }
  }

  function clearLogs(){
    if(!confirm('Vill du ta bort alla sparade k√∂rningar?')) return;
    localStorage.removeItem(STORAGE_KEY_LOGS);
    updateLogCount();
  }

  function updateLogCount(){
    const count=loadLogs().length;
    els.logCountTop.textContent=count;
    els.logCountTop.title=`${count} sparade loggar`;
  }

  function calibrateWithCurrentPosition(name, updateActiveRoute){
    const applyPosition=pos=>{
      if(!stationOverrides[name]) stationOverrides[name]={};
      stationOverrides[name].lat=pos.coords.latitude;
      stationOverrides[name].lon=pos.coords.longitude;
      saveStationOverrides();
      if(updateActiveRoute && state.route && state.route.length){
        state.route.forEach(st=>{
          if(st.name===name){
            st.lat=pos.coords.latitude;
            st.lon=pos.coords.longitude;
          }
        });
        renderRouteCards();
        renderRouteMap();
      }
      showJourneyMessage(`Uppdaterade ${name}`, false);
      setTimeout(()=>{ els.journeyMsg.style.display='none'; },3000);
    };
    if(state.lastPosition){
      applyPosition(state.lastPosition);
    }else if(navigator.geolocation){
      navigator.geolocation.getCurrentPosition(pos=>{
        state.lastPosition=pos;
        applyPosition(pos);
      }, err=>{
        showJourneyMessage(err&&err.message?err.message:'Kunde inte l√§sa GPS.', true);
      }, {enableHighAccuracy:true, timeout:20000});
    }else{
      showJourneyMessage('GPS saknas.', true);
    }
  }

  function loadStationOverrides(){
    try{
      const raw=localStorage.getItem(STORAGE_KEY_STATIONS);
      if(!raw) return {};
      const parsed=JSON.parse(raw);
      return parsed&&typeof parsed==='object'?parsed:{};
    }catch(e){
      return {};
    }
  }

  function saveStationOverrides(){
    try{
      localStorage.setItem(STORAGE_KEY_STATIONS, JSON.stringify(stationOverrides));
    }catch(e){}
  }

  function composeStationCatalog(){
    return baseStations.map(base=>{
      const override=stationOverrides[base.name]||{};
      const hasCustomRadius=override.radius!=null;
      const derivedRadius=hasCustomRadius?override.radius:(base.radius!=null?base.radius:DEFAULT_RADIUS);
      return {
        name:base.name,
        lat:override.lat!=null?override.lat:base.lat,
        lon:override.lon!=null?override.lon:base.lon,
        radius:isFinite(derivedRadius)?derivedRadius:DEFAULT_RADIUS,
        customRadius:hasCustomRadius
      };
    });
  }

  function showSetupError(text){
    els.setupError.textContent=text;
    els.setupError.style.display='inline-block';
  }

  function hideSetupError(){
    els.setupError.style.display='none';
  }

  function showJourneyMessage(text, isError){
    els.journeyMsg.textContent=text;
    els.journeyMsg.style.display='inline-block';
    els.journeyMsg.style.background=isError?'#fee2e2':'var(--soft)';
    els.journeyMsg.style.borderColor=isError?'#fecaca':'var(--softb)';
  }

  function resetForNewRun(){
    speedHistory.length=0; // rensa hastighetshistorik mellan k√∂rningar
    state.awaitingDepartureIndex=null;
    state.lastSpeed=null;
    state.lastSpeedTime=null;
    state.route=[];
    state.running=false;
    state.nextIndex=null;
    state.lastReachedIndex=0;
    els.report.style.display='none';
    els.journey.style.display='none';
    els.setup.style.display='block';
    els.cards.innerHTML='';
    updateNextStopUI();
  }

  function escapeHtml(str){
    return str.replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c]));
  }

  function haversine(lat1, lon1, lat2, lon2){
    const R=6371000;
    const toRad=deg=>deg*Math.PI/180;
    const dLat=toRad(lat2-lat1);
    const dLon=toRad(lon2-lon1);
    const a=Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
    const c=2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R*c;
  }

  // Stationssignaturer h√§mtas nu dynamiskt fr√•n API:t via station.sig

  async function fetchTimetable(otn, date){
    if(!otn) return { success: false, error: 'Inget t√•gnummer angivet' };
    try{
      const targetDate = date ? new Date(date) : new Date();
      const targetDateStr = targetDate.toISOString().split('T')[0];

      const xmlRequest = `<REQUEST>
        <LOGIN authenticationkey="${TRAFIKVERKET_API_KEY}" />
        <QUERY objecttype="TrainAnnouncement" schemaversion="1.9" limit="500">
          <FILTER>
            <EQ name="OperationalTrainNumber" value="${otn}" />
          </FILTER>
          <INCLUDE>LocationSignature</INCLUDE>
          <INCLUDE>AdvertisedTimeAtLocation</INCLUDE>
          <INCLUDE>ActivityType</INCLUDE>
          <INCLUDE>OperationalTrainNumber</INCLUDE>
          <INCLUDE>DepartureDateOTN</INCLUDE>
          <INCLUDE>Advertised</INCLUDE>
        </QUERY>
      </REQUEST>`;

      const response = await fetch(TRAFIKVERKET_API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'text/xml' },
        body: xmlRequest
      });

      if(!response.ok) {
        return { success: false, error: `API-fel: HTTP ${response.status}` };
      }

      const data = await response.json();
      const announcements = data?.RESPONSE?.RESULT?.[0]?.TrainAnnouncement || [];

      if(!announcements.length) {
        return { success: false, error: `T√•g ${otn} hittades inte i tidtabellen` };
      }

      const filtered = announcements.filter(ann => {
        if(!ann.AdvertisedTimeAtLocation) return false;
        const annDate = new Date(ann.AdvertisedTimeAtLocation).toISOString().split('T')[0];
        return annDate === targetDateStr;
      });

      if(!filtered.length) {
        const availableDates = [...new Set(announcements
          .filter(a => a.AdvertisedTimeAtLocation)
          .map(a => new Date(a.AdvertisedTimeAtLocation).toISOString().split('T')[0])
        )].sort();

        return {
          success: false,
          error: `T√•g ${otn} g√•r inte ${targetDateStr}. G√•r: ${availableDates.join(', ')}`
        };
      }

      const timetable = {};
      const stationStops = new Set();

      filtered.forEach(ann => {
        const sig = ann.LocationSignature;
        const time = ann.AdvertisedTimeAtLocation;
        const activity = ann.ActivityType;
        const advertised = ann.Advertised;

        if(!sig || !time) return;

        if(!timetable[sig]) timetable[sig] = { hasArrival: false, hasDeparture: false };

        if(activity === 'Ankomst') {
          timetable[sig].arrival = new Date(time);
          timetable[sig].hasArrival = true;
        } else if(activity === 'Avgang') {
          timetable[sig].departure = new Date(time);
          timetable[sig].hasDeparture = true;
        }
      });

      Object.keys(timetable).forEach(sig => {
        const info = timetable[sig];
        if(info.hasArrival || info.hasDeparture) {
          stationStops.add(sig);
        }
      });

      return {
        success: true,
        timetable,
        stationStops: Array.from(stationStops),
        stationCount: Object.keys(timetable).length
      };
    }catch(err){
      console.error('Kunde inte h√§mta tidtabell:', err);
      let errorMsg = 'Ok√§nt fel vid API-anrop';
      if(!navigator.onLine){
        errorMsg = 'Ingen internetanslutning ‚Äì tidtabell kunde inte h√§mtas';
      }else if(err.name === 'TypeError' && err.message.includes('fetch')){
        errorMsg = 'N√§tverksfel ‚Äì kontrollera anslutningen';
      }else if(err.message){
        errorMsg = err.message;
      }
      return { success: false, error: errorMsg };
    }
  }

  function applyTimetableToRoute(timetable){
    if(!timetable || !state.route) return;

    state.route.forEach((station, idx) => {
      // Use station.sig directly (set when route was built)
      const sig = station.sig;
      if(!sig || !timetable[sig]) return;

      const isFirst = idx === 0;
      const isLast = idx === state.route.length - 1;

      if(!isFirst && timetable[sig].arrival) {
        station.scheduledArrival = timetable[sig].arrival;
      }

      if(!isLast && timetable[sig].departure) {
        station.scheduledDeparture = timetable[sig].departure;
      }
    });
  }

  function filterRouteByTimetable(stationStops){
    if(!stationStops || !state.route) return;

    const stopsSet = new Set(stationStops);
    const newRoute = [];

    state.route.forEach((station, idx) => {
      // Use station.sig directly (set when route was built)
      const sig = station.sig;
      const isFirst = idx === 0;
      const isLast = idx === state.route.length - 1;

      if(isFirst || isLast || stopsSet.has(sig)) {
        station.shouldStop = true;
        newRoute.push(station);
      } else {
        station.shouldStop = false;
      }
    });

    if(newRoute.length > 0) {
      newRoute.forEach((station, idx) => {
        station.order = idx + 1;
      });

      state.route = newRoute;
      state.lastReachedIndex = 0;
      state.nextIndex = newRoute.length > 1 ? 1 : null;
    }
  }

  function normalizeLogEntry(entry){
    if(!entry || typeof entry!=='object') return null;
    const stopsArray=Array.isArray(entry.stops)?entry.stops:[];
    const firstStop=stopsArray[0]||{};
    const lastStop=stopsArray[stopsArray.length-1]||{};
    const endpoints=parseRouteEndpoints(entry.route);
    const startStation = entry.startStation || endpoints.start || firstStop.name || '';
    const endStation = entry.endStation || endpoints.end || lastStop.name || '';
    const startedAt = entry.startedAt || entry.date || firstStop.actualDeparture || firstStop.actualArrival || null;
    const finishedAt = entry.finishedAt || lastStop.actualArrival || lastStop.actualDeparture || null;
    const normalizedStops = stopsArray.map((stop,idx)=>({
      name: stop.name || stop.station || `Uppeh√•ll ${idx+1}`,
      actualArrival: stop.actualArrival || stop.arrival || stop.arr || null,
      actualDeparture: stop.actualDeparture || stop.departure || stop.dep || null,
      scheduledArrival: stop.scheduledArrival || null,
      scheduledDeparture: stop.scheduledDeparture || null,
      arrivalSource: stop.arrivalSource || '',
      departSource: stop.departSource || '',
      shouldStop: stop.shouldStop!=null ? !!stop.shouldStop : !stop.skipNoStop,
      excludeInboundRun: !!(stop.excludeInboundRun || stop.exclude)
    }));
    const rawId = entry.id || entry.measurementId || entry.measurementID || `${entry.trainNumber||''}|${startStation||''}|${startedAt||''}`;
    return {
      id: String(rawId || Date.now().toString(36)),
      trainNumber: entry.trainNumber || '',
      startStation: startStation || '',
      endStation: endStation || '',
      startedAt: startedAt || null,
      finishedAt: finishedAt || null,
      aborted: !!entry.aborted,
      notes: entry.notes || entry.note || '',
      stops: normalizedStops
    };
  }

  function dedupeLogs(logs){
    const seen=new Set();
    const out=[];
    for(const entry of logs||[]){
      if(!entry) continue;
      const key=entry.id || entry.measurementId || `${entry.trainNumber||''}|${entry.startStation||''}|${entry.startedAt||''}`;
      if(!seen.has(key)){
        seen.add(key);
        out.push(entry);
      }
    }
    return out;
  }

  function parseRouteEndpoints(route){
    if(typeof route!=='string') return {start:'', end:''};
    const parts=route.split(/[-‚Üí]/).map(s=>s.trim()).filter(Boolean);
    if(!parts.length) return {start:'', end:''};
    return { start: parts[0], end: parts[parts.length-1] };
  }

  async function requestWakeLock(){
    if(!('wakeLock' in navigator)){
      showHeaderStatus('Sk√§rml√•s st√∂ds inte i denna webbl√§sare.', true);
      return;
    }
    try{
      wakeLockSentinel=await navigator.wakeLock.request('screen');
      keepScreenAwake=true;
      wakeLockSentinel.addEventListener('release', ()=>{
        wakeLockSentinel=null;
        updateWakeButton();
        if(keepScreenAwake && document.visibilityState==='visible'){
          requestWakeLock().catch(()=>{});
        }
      });
      updateWakeButton();
      showHeaderStatus('Sk√§rmen h√•lls vaken.', false);
    }catch(err){
      keepScreenAwake=false;
      wakeLockSentinel=null;
      updateWakeButton();
      showHeaderStatus('Kunde inte l√•sa sk√§rmen vaken.', true);
    }
  }

  function releaseWakeLock(){
    keepScreenAwake=false;
    if(wakeLockSentinel){
      wakeLockSentinel.release();
      wakeLockSentinel=null;
    }
    updateWakeButton();
    showHeaderStatus('Sk√§rmen f√•r slockna.', false);
  }

  function toggleWakeLock(){
    if(keepScreenAwake){
      releaseWakeLock();
    }else{
      requestWakeLock();
    }
  }

  function updateWakeButton(){
    if(!els.wakeBtn) return;
    els.wakeBtn.textContent=keepScreenAwake?'Till√•t sk√§rmen slockna':'H√•ll sk√§rmen vaken';
    els.wakeBtn.setAttribute('aria-pressed', keepScreenAwake?'true':'false');
    els.wakeBtn.classList.toggle('primary', keepScreenAwake);
  }

  function handleVisibilityChange(){
    if(document.visibilityState==='visible'){
      if(keepScreenAwake && !wakeLockSentinel){
        requestWakeLock();
      }
      // Check if journey was interrupted while in background
      if(state.running){
        const saved = loadActiveJourney();
        if(saved && saved.lastSaveTime){
          const timeSinceLastSave = Date.now() - saved.lastSaveTime;
          if(timeSinceLastSave > 60000){ // More than 1 minute
            showJourneyMessage(`Appen var i bakgrunden i ${Math.round(timeSinceLastSave/60000)} min - GPS forts√§tter`, false);
            setTimeout(() => { els.journeyMsg.style.display='none'; }, 5000);
          }
        }
      }
    }else if(document.visibilityState==='hidden'){
      // Save journey when going to background
      if(state.running){
        saveActiveJourney();
      }
    }
  }

  // === Active Journey Persistence ===

  function saveActiveJourney(){
    if(!state.running || !state.route.length) return;
    try{
      const journeyState = {
        running: state.running,
        route: state.route,
        trainNumber: state.trainNumber,
        vehicleType: state.vehicleType,
        notes: state.notes,
        startedAt: state.startedAt,
        lastReachedIndex: state.lastReachedIndex,
        nextIndex: state.nextIndex,
        awaitingDepartureIndex: state.awaitingDepartureIndex,
        lastSaveTime: Date.now()
      };
      localStorage.setItem(STORAGE_KEY_ACTIVE_JOURNEY, JSON.stringify(journeyState));
    }catch(e){
      console.warn('Could not save active journey:', e);
    }
  }

  function loadActiveJourney(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY_ACTIVE_JOURNEY);
      if(!raw) return null;
      return JSON.parse(raw);
    }catch(e){
      return null;
    }
  }

  function clearActiveJourney(){
    try{
      localStorage.removeItem(STORAGE_KEY_ACTIVE_JOURNEY);
    }catch(e){}
  }

  function checkForInterruptedJourney(){
    const saved = loadActiveJourney();
    if(!saved || !saved.running || !saved.route || !saved.route.length) return;

    // Check if journey is less than 12 hours old
    const journeyAge = Date.now() - new Date(saved.startedAt).getTime();
    if(journeyAge > 12 * 60 * 60 * 1000){
      clearActiveJourney();
      return;
    }

    // Show resume dialog
    const startStation = saved.route[0]?.name || '?';
    const endStation = saved.route[saved.route.length-1]?.name || '?';
    const startTime = saved.startedAt ? new Date(saved.startedAt).toLocaleTimeString('sv-SE', {hour:'2-digit', minute:'2-digit'}) : '?';

    const resumeDialog = document.createElement('div');
    resumeDialog.id = 'resumeDialog';
    resumeDialog.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);z-index:1000;display:flex;align-items:center;justify-content:center;padding:1rem;';
    resumeDialog.innerHTML = `
      <div style="background:var(--card-bg);border:1px solid var(--pri);border-radius:12px;padding:1.5rem;max-width:400px;width:100%;">
        <h3 style="margin:0 0 1rem;color:var(--pri);">√Öteruppta resa?</h3>
        <p style="margin:0 0 .5rem;color:var(--ink);">En p√•g√•ende resa hittades:</p>
        <p style="margin:0 0 1rem;color:var(--ink-dim);font-size:.9rem;">
          <strong>${startStation} ‚Üí ${endStation}</strong><br>
          Fordon: ${saved.vehicleType || '‚Äì'} ‚Ä¢ T√•g: ${saved.trainNumber || '‚Äì'}<br>
          Startad: ${startTime}
        </p>
        <div style="display:flex;gap:.5rem;flex-wrap:wrap;">
          <button id="btnResumeJourney" class="primary" style="flex:1;">√Öteruppta</button>
          <button id="btnDiscardJourney" class="danger" style="flex:1;">Kasta bort</button>
        </div>
      </div>
    `;
    document.body.appendChild(resumeDialog);

    document.getElementById('btnResumeJourney').addEventListener('click', () => {
      resumeJourney(saved);
      resumeDialog.remove();
    });

    document.getElementById('btnDiscardJourney').addEventListener('click', () => {
      clearActiveJourney();
      resumeDialog.remove();
    });
  }

  function resumeJourney(saved){
    // Restore state
    state.running = true;
    state.route = saved.route;
    state.trainNumber = saved.trainNumber;
    state.vehicleType = saved.vehicleType;
    state.notes = saved.notes;
    state.startedAt = saved.startedAt ? new Date(saved.startedAt) : new Date();
    state.lastReachedIndex = saved.lastReachedIndex || 0;
    state.nextIndex = saved.nextIndex;
    state.awaitingDepartureIndex = saved.awaitingDepartureIndex;
    state.aborted = false;

    // Update UI
    hideSetupError();
    els.setup.style.display = 'none';
    els.journey.style.display = 'block';
    els.report.style.display = 'none';

    const startName = state.route[0]?.name || '?';
    const endName = state.route[state.route.length-1]?.name || '?';
    els.journeyTitle.textContent = `${startName} ‚Üí ${endName} ‚Ä¢ ${state.vehicleType} ‚Ä¢ t√•g ${state.trainNumber||'‚Äì'}`;

    renderRouteCards();
    renderRouteMap();
    requestGpsWatch();

    showJourneyMessage('Resa √•terupptagen!', false);
    setTimeout(() => { els.journeyMsg.style.display='none'; }, 3000);
  }

  function setupPWA(){
    if(window.matchMedia && window.matchMedia('(display-mode: standalone)').matches){
      hideInstallButton();
    }
    if('serviceWorker' in navigator){
      window.addEventListener('load', ()=>{
        navigator.serviceWorker.register(`./sw.js?v=${APP_VERSION}`).then(reg=>{
          monitorServiceWorker(reg);
        }).catch(err=>{
          console.warn('Service worker misslyckades', err);
        });
      });
      navigator.serviceWorker.addEventListener('controllerchange', ()=>{
        if(updateTriggered){
          window.location.reload();
        }
      });
    }
    window.addEventListener('beforeinstallprompt', event=>{
      event.preventDefault();
      deferredInstallPrompt=event;
      if(els.installBtn){
        els.installBtn.style.display='inline-block';
      }
    });
    window.addEventListener('appinstalled', ()=>{
      showHeaderStatus('Appen installerades!', false);
      hideInstallButton();
    });
    if(els.installBtn){
      els.installBtn.addEventListener('click', async ()=>{
        if(!deferredInstallPrompt) return;
        els.installBtn.disabled=true;
        try{
          deferredInstallPrompt.prompt();
          const choice=await deferredInstallPrompt.userChoice;
          if(choice && choice.outcome==='accepted'){
            showHeaderStatus('Installationen startar‚Ä¶', false);
            hideInstallButton();
          }else{
            showHeaderStatus('Installationen avbr√∂ts.', true);
          }
        }catch(err){
          showHeaderStatus('Kunde inte starta installationen.', true);
        }finally{
          deferredInstallPrompt=null;
          els.installBtn.disabled=false;
        }
      });
    }
  }

  function monitorServiceWorker(reg){
    function listenForInstall(worker){
      if(!worker) return;
      worker.addEventListener('statechange', ()=>{
        if(worker.state==='installed'){
          if(navigator.serviceWorker.controller){
            pendingServiceWorker=worker;
            showUpdatePrompt();
          }
        }
      });
    }
    if(reg.waiting && navigator.serviceWorker.controller){
      pendingServiceWorker=reg.waiting;
      showUpdatePrompt();
    }
    if(reg.installing){
      listenForInstall(reg.installing);
    }
    reg.addEventListener('updatefound', ()=>{
      listenForInstall(reg.installing);
    });
  }

  function hideInstallButton(){
    if(els.installBtn){
      els.installBtn.style.display='none';
    }
  }

  function showUpdatePrompt(){
    if(!els.updateBtn) return;
    els.updateBtn.style.display='inline-block';
    els.updateBtn.disabled=false;
    showHeaderStatus('Ny version finns ‚Äì uppdatera appen.', false);
  }

  function showHeaderStatus(text, isError){
    if(!els.headerStatus) return;
    els.headerStatus.textContent=text;
    els.headerStatus.style.display='inline-block';
    els.headerStatus.style.background=isError?'#fee2e2':'#dcfce7';
    els.headerStatus.style.borderColor=isError?'#fecaca':'#86efac';
    clearTimeout(showHeaderStatus._timer);
    showHeaderStatus._timer=setTimeout(()=>{
      els.headerStatus.style.display='none';
    },4000);
  }

  init();
})();
</script>
</body>
</html>
