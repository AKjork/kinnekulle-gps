<!DOCTYPE html>
<html lang="sv">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#2563eb">
<title>Kinnekulle T√•gmonitor ‚Äì GPS-version</title>
<link rel="manifest" href="kinnekulle-gps.webmanifest">
<link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<style>
  :root{
    --bg:#1a1d23;
    --bg-solid:#0d0f12;
    --ink:#e8eaed;
    --ink-dim:#9aa0a6;
    --mut:#6b7280;
    --pri:#22c55e;
    --pri-dark:#16a34a;
    --pri-glow:rgba(34,197,94,0.15);
    --sec:#f59e0b;
    --b:#2d3139;
    --b-light:#3d4149;
    --soft:rgba(34,197,94,0.1);
    --softb:#22c55e;
    --err:#ef4444;
    --err-bg:rgba(239,68,68,0.15);
    --good:#22c55e;
    --good-bg:rgba(34,197,94,0.15);
    --card-bg:#1e2128;
    --warn:#f59e0b;
    --warn-bg:rgba(245,158,11,0.15);
    --blue:#3b82f6;
    --blue-bg:rgba(59,130,246,0.15);
  }
  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html{font-size:15px}
  body{
    font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
    margin:0;
    padding:0;
    line-height:1.5;
    background:var(--bg-solid);
    color:var(--ink);
    min-height:100vh;
    min-height:100dvh;
  }
  header{
    position:sticky;
    top:0;
    background:var(--bg);
    padding:.75rem 1rem;
    margin:0;
    border-bottom:1px solid var(--b);
    z-index:10;
  }
  h1{
    margin:0 0 .5rem;
    font-size:1.1rem;
    font-weight:600;
    color:var(--ink);
    letter-spacing:-0.01em;
  }
  h1::before{content:'üöÇ '}
  h2{
    margin:1.25rem 0 .75rem;
    font-size:1rem;
    font-weight:600;
    color:var(--ink);
  }
  h2::before{content:''}
  main{padding:.75rem;max-width:600px;margin:0 auto}
  .bar{display:flex;gap:.4rem;flex-wrap:wrap;align-items:center}
  .row{display:flex;gap:.4rem;flex-wrap:wrap}
  .grow{flex:1 1 auto}
  .form-group{margin:.5rem 0}
  label{display:block;margin:.2rem 0;font-weight:500;color:var(--ink-dim);font-size:.8rem;text-transform:uppercase;letter-spacing:.03em}
  input,select,button,textarea{
    font-size:.95rem;
    padding:.5rem .75rem;
    border:1px solid var(--b);
    border-radius:6px;
    font-family:inherit;
    background:var(--card-bg);
    color:var(--ink);
    transition:border-color 0.15s,box-shadow 0.15s;
  }
  input:focus,select:focus,textarea:focus{
    outline:none;
    border-color:var(--pri);
    box-shadow:0 0 0 2px var(--pri-glow);
  }
  input[type="checkbox"]{
    padding:0;
    width:1.1rem;
    height:1.1rem;
    border-radius:4px;
    accent-color:var(--pri);
  }
  select{background:var(--card-bg)}
  button{
    cursor:pointer;
    font-weight:500;
    font-size:.85rem;
    padding:.4rem .7rem;
    transition:all 0.15s ease;
    border:1px solid var(--b);
    background:var(--card-bg);
    color:var(--ink);
  }
  button:hover:not(:disabled){background:var(--b)}
  button:active:not(:disabled){transform:scale(0.98)}
  button.primary{
    background:var(--pri);
    color:#000;
    border-color:var(--pri);
    font-weight:600;
  }
  button.primary:hover:not(:disabled){background:var(--pri-dark)}
  button.ghost{
    background:transparent;
    color:var(--pri);
    border-color:var(--b);
  }
  button.ghost:hover:not(:disabled){background:var(--pri-glow);border-color:var(--pri)}
  button.danger{
    background:transparent;
    color:var(--err);
    border-color:var(--b);
  }
  button.danger:hover:not(:disabled){background:var(--err-bg);border-color:var(--err)}
  button:disabled{opacity:.4;cursor:not-allowed}
  button.sm{padding:.25rem .5rem;font-size:.75rem}
  .cards{
    display:flex;
    flex-direction:column;
    gap:.5rem;
    margin:.75rem 0;
  }
  .card{
    border:1px solid var(--b);
    border-radius:8px;
    padding:.6rem .75rem;
    background:var(--card-bg);
    transition:border-color 0.2s,background 0.2s;
  }
  .card:hover{border-color:var(--b-light)}
  .card.active{
    border-color:var(--pri);
    background:linear-gradient(135deg, var(--card-bg) 0%, rgba(34,197,94,0.05) 100%);
    box-shadow:0 0 0 1px var(--pri-glow);
  }
  .card.done{opacity:0.6}
  .card-header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:.5rem;
    cursor:pointer;
  }
  .card h3{
    margin:0;
    font-size:.95rem;
    font-weight:600;
    color:var(--ink);
    display:flex;
    align-items:center;
    gap:.4rem;
  }
  .card h3 .station-num{
    color:var(--mut);
    font-weight:400;
    font-size:.8rem;
    min-width:1.5rem;
  }
  .card-times{
    display:flex;
    gap:.75rem;
    font-size:.8rem;
    color:var(--ink-dim);
    margin-top:.35rem;
  }
  .card-times strong{color:var(--ink);font-weight:600}
  .card-times .arr::before{content:'‚Üì ';color:var(--pri)}
  .card-times .dep::before{content:'‚Üë ';color:var(--sec)}
  .card-expand{
    max-height:0;
    overflow:hidden;
    transition:max-height 0.25s ease;
  }
  .card.expanded .card-expand{max-height:20rem}
  .card-expand-inner{
    padding-top:.6rem;
    margin-top:.5rem;
    border-top:1px solid var(--b);
  }
  .card-toggle{
    width:1.5rem;
    height:1.5rem;
    border-radius:4px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:.7rem;
    color:var(--mut);
    transition:transform 0.2s;
  }
  .card.expanded .card-toggle{transform:rotate(180deg)}
  .meta{font-size:.75rem;color:var(--mut);line-height:1.4}
  .badge{
    background:var(--b);
    border-radius:4px;
    padding:.15rem .4rem;
    font-size:.7rem;
    font-weight:600;
    display:inline-flex;
    align-items:center;
    color:var(--ink-dim);
  }
  .badge.live{background:var(--good-bg);color:var(--good)}
  .badge.warn{background:var(--err-bg);color:var(--err)}
  .badge.early{background:var(--blue-bg);color:var(--blue)}
  .badge.late{background:var(--warn-bg);color:var(--warn)}
  .badge.very-late{background:var(--err-bg);color:var(--err)}
  .badge.dist{background:transparent;color:var(--ink-dim);font-weight:500;font-variant-numeric:tabular-nums}
  .scheduled{font-size:.7rem;color:var(--mut);margin:.15rem 0 0}
  .status-grid{
    display:grid;
    grid-template-columns:repeat(2,1fr);
    gap:.5rem;
    margin:.75rem 0;
  }
  .status-box{
    border:1px solid var(--b);
    border-radius:8px;
    padding:.6rem .75rem;
    background:var(--card-bg);
  }
  .status-box h4{
    margin:0 0 .2rem;
    font-size:.65rem;
    color:var(--mut);
    text-transform:uppercase;
    letter-spacing:.04em;
    font-weight:600;
  }
  .status-box strong{font-size:1rem;color:var(--ink);font-weight:600;display:block}
  .status-box .meta{margin-top:.15rem}
  .control-row{margin:.4rem 0}
  .control-row label{
    display:inline-flex;
    align-items:center;
    gap:.4rem;
    font-size:.8rem;
    color:var(--ink-dim);
    text-transform:none;
    letter-spacing:0;
    cursor:pointer;
  }
  .card-actions{margin-top:.5rem;gap:.4rem;flex-wrap:wrap}
  .table-wrap{overflow-x:auto;border-radius:8px;border:1px solid var(--b)}
  table{border-collapse:collapse;width:100%;background:var(--card-bg);font-size:.8rem}
  th,td{border:1px solid var(--b);padding:.5rem .6rem;text-align:left}
  th{background:var(--bg);color:var(--ink-dim);font-weight:600;font-size:.7rem;text-transform:uppercase;letter-spacing:.03em}
  td input{width:5rem;padding:.3rem .4rem;font-size:.8rem}
  details{
    border:1px solid var(--b);
    border-radius:8px;
    padding:.75rem;
    background:var(--card-bg);
    margin-top:1rem;
  }
  summary{cursor:pointer;font-weight:500;font-size:.9rem;color:var(--ink)}
  summary::before{content:'‚öôÔ∏è ';font-size:.8rem}
  footer{margin-top:2rem;color:var(--mut);font-size:.75rem;text-align:center;padding:.75rem}
  code{
    font-family:ui-monospace,monospace;
    font-size:.8rem;
    background:var(--b);
    color:var(--ink);
    padding:.15rem .35rem;
    border-radius:4px;
  }
  @media (max-width:640px){
    html{font-size:14px}
    header{padding:.6rem .75rem}
    h1{font-size:1rem}
    main{padding:.5rem}
    .status-grid{grid-template-columns:1fr 1fr}
    .status-box{padding:.5rem}
    .bar{gap:.3rem}
    button{padding:.35rem .6rem}
  }
  @media (min-width:641px){
    .cards{max-width:500px}
  }
</style>
</head>
<body>
<header>
  <h1>Kinnekulle T√•gmonitor ‚Äì GPS-version</h1>
  <div class="bar">
    <button id="btnExport" class="primary" aria-label="Exportera sparade k√∂rningar som JSON">JSON</button>
    <button id="btnExportCSV" class="primary" aria-label="Exportera sparade k√∂rningar som CSV">CSV</button>
    <button id="btnSaveFile" class="ghost" aria-label="Spara loggar till fil">Spara loggar</button>
    <button id="btnSync" class="ghost" aria-label="Synkronisera loggfil">Synka loggfil</button>
    <button id="btnClear" class="ghost" aria-label="Ta bort alla sparade k√∂rningar">T√∂m loggar</button>
    <button id="btnWakeLock" class="ghost" aria-pressed="false" aria-label="Hindra att sk√§rmen slocknar">H√•ll sk√§rmen vaken</button>
    <button id="btnUpdate" class="ghost" style="display:none" aria-label="Ladda om med ny version">Uppdatera appen</button>
    <button id="btnInstall" class="ghost" style="display:none" aria-label="Installera som app">Installera appen</button>
    <span id="headerStatus" class="badge" style="display:none"></span>
    <span id="offlineIndicator" class="badge warn" style="display:none" role="status" aria-live="polite">‚ö° Offline</span>
    <span id="logCountTop" class="badge" role="status" aria-live="polite" style="margin-left:auto">Loggar: 0</span>
    <span id="gpsStatusBadge" class="badge">Ingen GPS √§nnu</span>
  </div>
</header>

<main>
  <section id="setup">
    <h2>1. St√§ll in resan</h2>
    <div class="form-group">
      <label for="trainNumber">Operativt t√•gnummer (valfritt)</label>
      <input id="trainNumber" type="text" placeholder="t.ex. 8074">
    </div>
    <div id="routeSuggestion" style="display:none;margin:.6rem 0;padding:.75rem;background:var(--pri-glow);border:1px solid var(--pri);border-radius:8px">
      <div style="display:flex;align-items:center;gap:.4rem;margin-bottom:.4rem">
        <span style="font-size:1rem">üí°</span>
        <strong style="color:var(--pri)">F√∂rslag fr√•n historik</strong>
      </div>
      <p id="suggestionText" style="margin:.2rem 0;font-size:.9rem;color:var(--ink)"></p>
      <div class="bar" style="margin-top:.5rem">
        <button id="btnAcceptSuggestion" class="primary">‚úì Anv√§nd</button>
        <button id="btnIgnoreSuggestion" class="ghost">√Ñndra</button>
      </div>
    </div>
    <div class="row">
      <div class="form-group">
        <label for="startStation">Startstation</label>
        <select id="startStation"></select>
      </div>
      <div class="form-group">
        <label for="endStation">Slutstation</label>
        <select id="endStation"></select>
      </div>
    </div>
    <div class="form-group">
      <label for="startNotes">Anteckningar (syns i rapporten)</label>
      <textarea id="startNotes" rows="2" placeholder="Skriv h√§r om du vill anteckna n√•got om m√§tningen ‚Ä¶"></textarea>
    </div>
    <div class="bar">
      <button id="btnStart" class="primary">Starta GPS-resan</button>
      <span id="setupError" class="badge warn" style="display:none"></span>
    </div>
  </section>

  <section id="journey" style="display:none">
    <h2 id="journeyTitle">Aktiv resa</h2>
    <div class="status-grid">
      <div class="status-box">
        <h4>GPS-status</h4>
        <strong id="gpsStatusText">‚Äì</strong>
        <div class="meta" id="gpsAccuracy">Noggrannhet: ‚Äì</div>
      </div>
      <div class="status-box">
        <h4>Senaste position</h4>
        <strong id="gpsCoords">‚Äì</strong>
        <div class="meta" id="gpsTimestamp">‚Äì</div>
      </div>
      <div class="status-box">
        <h4>Hastighet</h4>
        <strong id="gpsSpeed">‚Äì</strong>
        <div class="meta" id="gpsExtra">Ingen r√∂relse registrerad</div>
      </div>
      <div class="status-box">
        <h4>N√§sta station</h4>
        <strong id="nextStop">‚Äì</strong>
        <div class="meta" id="nextStopInfo">Ingen aktiv resa</div>
      </div>
    </div>
    <div class="bar" style="margin:1rem 0">
      <button id="btnFinish" class="primary">Avsluta & spara</button>
      <button id="btnAbort" class="danger">Avbryt resa</button>
      <span id="journeyMsg" class="badge" style="display:none"></span>
    </div>
    <div id="cards" class="cards"></div>
  </section>

  <section id="report" style="display:none">
    <h2>Rapport</h2>
    <div id="reportHTML"></div>
    <div class="bar" style="margin-top:1rem">
      <button id="btnNew" class="ghost">Starta ny m√§tning</button>
    </div>
  </section>

  <section id="calibration">
    <details>
      <summary>Stationernas GPS-punkter och radier</summary>
      <p>Appen anv√§nder geofencing runt varje station. Justera koordinaterna om du st√•r i n√§rheten men det inte registreras. Radien anges i meter.</p>
      <div class="bar" style="margin-bottom:.5rem">
        <span class="badge" id="calibrationMsg" style="display:none"></span>
      </div>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>Station</th>
              <th>Lat</th>
              <th>Lon</th>
              <th>Radie (m)</th>
              <th>√Ötg√§rd</th>
            </tr>
          </thead>
          <tbody id="calibrationBody"></tbody>
        </table>
      </div>
    </details>
  </section>
</main>

<footer>
  Tips: K√∂r sidan via <code>https://</code> p√• mobilen f√∂r att f√• tillg√•ng till h√∂guppl√∂st GPS. All data sparas endast lokalt i webbl√§saren.
</footer>

<script>
(function(){
  'use strict';

  const APP_VERSION = '2024-11-24b';
  const DEFAULT_RADIUS = 100;
  const EXTRA_MARGIN = 120;
  const SPEED_THRESHOLD_KMH = 5;
  const SPEED_THRESHOLD_MS = SPEED_THRESHOLD_KMH / 3.6;
  const CLOSE_APPROACH_EPS = 1; // meters
  const PASS_DISTANCE_MARGIN = 5; // meters before we consider leaving after pass
  const DEPART_REVERT_WINDOW_MS = 120000; // allow 2 min to re-time a premature departure
  const STORAGE_KEY_LOGS = 'kmon_gps_logs_v1';
  const STORAGE_KEY_STATIONS = 'kmon_gps_station_meta_v1';
  const STORAGE_KEY_SAVE_FILE = 'kmon_gps_file_handle_v1';
  const STORAGE_KEY_ROUTE_HISTORY = 'kmon_gps_route_history_v1';
  const TRAFIKVERKET_API_KEY = '1acaea82911c472cb3409d57ae19707f';
  const TRAFIKVERKET_API_URL = 'https://api.trafikinfo.trafikverket.se/v2/data.json';

  const baseStations = [
    { name: 'Herrljunga', lat: 58.0788605, lon: 13.0208614, radius: 100 },
    { name: 'Vedum', lat: 58.169087, lon: 12.9986447, radius: 100 },
    { name: 'Vara', lat: 58.2606711, lon: 12.9522447, radius: 100 },
    { name: 'H√•kantorp', lat: 58.3070206, lon: 12.9073349, radius: 100 },
    { name: 'Stora Levene', lat: 58.3260448, lon: 12.9258804, radius: 100 },
    { name: 'J√§rp√•s', lat: 58.3790122, lon: 12.9700919, radius: 100 },
    { name: 'Lovene', lat: 58.4411096, lon: 13.0479129, radius: 100 },
    { name: 'Framn√§s City', lat: 58.5076929, lon: 13.1470414, radius: 100 },
    { name: 'Lidk√∂ping', lat: 58.50462, lon: 13.1639339, radius: 100 },
    { name: 'Filsb√§ck', lat: 58.4931843, lon: 13.2469536, radius: 100 },
    { name: 'K√§llby', lat: 58.5107931, lon: 13.3023402, radius: 100 },
    { name: 'Blomberg', lat: 58.5402058, lon: 13.3206466, radius: 100 },
    { name: 'Trolmen', lat: 58.594665, lon: 13.3477718, radius: 100 },
    { name: 'R√•b√§ck', lat: 58.6105061, lon: 13.376454, radius: 100 },
    { name: 'H√§llekis', lat: 58.6302156, lon: 13.432943, radius: 100 },
    { name: 'Forshem', lat: 58.6180186, lon: 13.4912688, radius: 100 },
    { name: '√ñster√§ng', lat: 58.63415, lon: 13.5598621, radius: 100 },
    { name: '√Ñskek√§rr', lat: 58.6260531, lon: 13.6088607, radius: 100 },
    { name: 'Lugn√•s', lat: 58.6443788, lon: 13.7022008, radius: 100 },
    { name: 'Mariestad', lat: 58.7112536, lon: 13.8255412, radius: 100 },
    { name: 'Hassler√∂r', lat: 58.7491527, lon: 13.9404069, radius: 100 },
    { name: 'Lyrestad', lat: 58.8036306, lon: 14.0591279, radius: 100 },
    { name: 'Torved', lat: 58.8242178, lon: 14.1007891, radius: 100 },
    { name: 'Hova', lat: 58.8547965, lon: 14.2153363, radius: 100 },
    { name: 'G√•rdsj√∂', lat: 58.8721468, lon: 14.3335353, radius: 100 },
    { name: 'Lax√•', lat: 58.9893982, lon: 14.6185188, radius: 100 },
    { name: 'Hallsberg personbang√•rd', lat: 59.0671196, lon: 15.1107975, radius: 100 },
    { name: 'Kumla', lat: 59.126913, lon: 15.1406426, radius: 100 },
    { name: '√ñrebro S√∂dra', lat: 59.2697009, lon: 15.2020665, radius: 100 },
    { name: '√ñrebro Central', lat: 59.278536, lon: 15.2116615, radius: 100 }
  ];

  const els = {
    startSel: document.getElementById('startStation'),
    endSel: document.getElementById('endStation'),
    cards: document.getElementById('cards'),
    setup: document.getElementById('setup'),
    journey: document.getElementById('journey'),
    report: document.getElementById('report'),
    saveBtn: document.getElementById('btnSaveFile'),
    setupError: document.getElementById('setupError'),
    journeyMsg: document.getElementById('journeyMsg'),
    reportHTML: document.getElementById('reportHTML'),
    gpsStatusBadge: document.getElementById('gpsStatusBadge'),
    gpsStatusText: document.getElementById('gpsStatusText'),
    gpsAccuracy: document.getElementById('gpsAccuracy'),
    gpsCoords: document.getElementById('gpsCoords'),
    gpsTimestamp: document.getElementById('gpsTimestamp'),
    gpsSpeed: document.getElementById('gpsSpeed'),
    gpsExtra: document.getElementById('gpsExtra'),
    nextStop: document.getElementById('nextStop'),
    nextStopInfo: document.getElementById('nextStopInfo'),
    journeyTitle: document.getElementById('journeyTitle'),
    logCountTop: document.getElementById('logCountTop'),
    calibrationBody: document.getElementById('calibrationBody'),
    calibrationMsg: document.getElementById('calibrationMsg'),
    installBtn: document.getElementById('btnInstall'),
    updateBtn: document.getElementById('btnUpdate'),
    headerStatus: document.getElementById('headerStatus'),
    wakeBtn: document.getElementById('btnWakeLock')
  };

  let stationOverrides = loadStationOverrides();
  let stationCatalog = composeStationCatalog();
  let currentSuggestion = null;

  const state = {
    running: false,
    watchId: null,
    route: [],
    trainNumber: '',
    notes: '',
    startedAt: null,
    lastPosition: null,
    lastFixTime: null,
    lastSpeed: null,
    lastSpeedTime: null,
    lastReachedIndex: 0,
    nextIndex: null,
    awaitingDepartureIndex: null,
    departureProvisionalIdx: null,
    autoReason: '',
    aborted: false
  };
  let deferredInstallPrompt = null;
  let wakeLockSentinel = null;
  let keepScreenAwake = false;
  let pendingServiceWorker = null;
  let updateTriggered = false;
  let hadController = !!navigator.serviceWorker.controller;

  function init(){
    populateStationSelects();
    renderCalibrationTable();
    updateLogCount();
    bindEvents();
    setupPWA();
    updateWakeButton();
    setupOnlineStatus();
  }

  // Vibration feedback for arrivals/departures
  function vibrate(pattern){
    if('vibrate' in navigator){
      try{ navigator.vibrate(pattern); }catch(e){}
    }
  }

  // Online/offline status
  function setupOnlineStatus(){
    updateOnlineStatus();
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);
  }

  function updateOnlineStatus(){
    const indicator = document.getElementById('offlineIndicator');
    if(!indicator) return;
    if(navigator.onLine){
      indicator.style.display = 'none';
    }else{
      indicator.style.display = 'inline-flex';
    }
  }

  function populateStationSelects(preserveSelection){
    const currentStart=preserveSelection?els.startSel.value:null;
    const currentEnd=preserveSelection?els.endSel.value:null;
    const fragStart=new DocumentFragment();
    const fragEnd=new DocumentFragment();
    stationCatalog.forEach(st=>{
      const opt1=document.createElement('option');
      opt1.value=st.name;
      opt1.textContent=st.name;
      fragStart.appendChild(opt1);
      const opt2=document.createElement('option');
      opt2.value=st.name;
      opt2.textContent=st.name;
      fragEnd.appendChild(opt2);
    });
    els.startSel.innerHTML='';
    els.endSel.innerHTML='';
    els.startSel.appendChild(fragStart);
    els.endSel.appendChild(fragEnd);
    const startExists=stationCatalog.some(s=>s.name===currentStart);
    const endExists=stationCatalog.some(s=>s.name===currentEnd);
    els.startSel.value=startExists&&currentStart?currentStart:'Lidk√∂ping';
    els.endSel.value=endExists&&currentEnd?currentEnd:'Mariestad';
  }

  function bindEvents(){
    document.getElementById('btnStart').addEventListener('click', startJourney);
    document.getElementById('btnAbort').addEventListener('click', () => stopJourney(true, 'Resan avbr√∂ts manuellt'));
    document.getElementById('btnFinish').addEventListener('click', () => stopJourney(false, 'Avslutad manuellt'));
    document.getElementById('btnExport').addEventListener('click', exportLogs);
    document.getElementById('btnExportCSV').addEventListener('click', exportLogsCSV);
    if(els.saveBtn){
      els.saveBtn.addEventListener('click', saveLogsToFile);
    }
    document.getElementById('btnClear').addEventListener('click', clearLogs);
    document.getElementById('btnSync').addEventListener('click', syncLogs);
    document.getElementById('btnNew').addEventListener('click', resetForNewRun);
    els.cards.addEventListener('click', handleCardButton);
    els.cards.addEventListener('change', handleCardChange);
    els.calibrationBody.addEventListener('input', handleCalibrationInput);
    els.calibrationBody.addEventListener('click', handleCalibrationClick);
    if(els.wakeBtn){
      els.wakeBtn.addEventListener('click', toggleWakeLock);
    }
    if(els.updateBtn){
      els.updateBtn.addEventListener('click', ()=> {
        if(pendingServiceWorker){
          updateTriggered=true;
          els.updateBtn.disabled=true;
          showHeaderStatus('Uppdaterar appen‚Ä¶', false);
          pendingServiceWorker.postMessage({type:'SKIP_WAITING'});
          pendingServiceWorker=null;
        }else{
          window.location.reload();
        }
      });
    }
    document.addEventListener('visibilitychange', handleVisibilityChange);

    document.getElementById('trainNumber').addEventListener('input', handleTrainNumberInput);
    document.getElementById('btnAcceptSuggestion').addEventListener('click', acceptSuggestion);
    document.getElementById('btnIgnoreSuggestion').addEventListener('click', () => {
      document.getElementById('routeSuggestion').style.display='none';
      currentSuggestion = null;
    });
  }

  async function startJourney(){
    speedHistory.length=0; // nollst√§ller tidigare hastighetsposter inf√∂r ny resa
    state.awaitingDepartureIndex=null;
    state.departureProvisionalIdx=null;
    state.lastSpeed=null;
    state.lastSpeedTime=null;
    const startName=els.startSel.value;
    const endName=els.endSel.value;
    if(startName===endName){
      showSetupError('Start- och slutstation m√•ste vara olika.');
      return;
    }
    const startIdx=stationCatalog.findIndex(s=>s.name===startName);
    const endIdx=stationCatalog.findIndex(s=>s.name===endName);
    if(startIdx<0||endIdx<0){
      showSetupError('Kunde inte hitta stationerna.');
      return;
    }
    const forward=startIdx<endIdx;
    const slice=forward ? stationCatalog.slice(startIdx,endIdx+1) : stationCatalog.slice(endIdx,startIdx+1).reverse();
    const route=slice.map((st,idx)=>({
      name:st.name,
      lat:st.lat,
      lon:st.lon,
      radius:isFinite(st.radius)?st.radius:DEFAULT_RADIUS,
      customRadius:!!st.customRadius,
      actualArrival:null,
      actualDeparture:null,
      scheduledArrival:null,
      scheduledDeparture:null,
      arrivalSource:'',
      departSource:'',
      arrivalPosition:null,
      departurePosition:null,
      shouldStop:true,
      excludeInboundRun:false,
      inZone:false,
      lastSeenDistance:null,
      passThrough:false,
      needsArrivalRetiming:false,
      reachedLowSpeed:false,
      closestDistance:null,
      closestTime:null,
      closestPosition:null,
      departureProvisional:false,
      departureProvisionalAt:null,
      order:idx+1
    }));
    state.route=route;
    state.running=true;
    state.trainNumber=(document.getElementById('trainNumber').value||'').trim();
    state.notes=(document.getElementById('startNotes').value||'').trim();
    state.startedAt=new Date();
    state.lastReachedIndex=0;
    state.nextIndex=route.length>1?1:null;
    state.autoReason='';
    state.aborted=false;
    hideSetupError();
    els.setup.style.display='none';
    els.journey.style.display='block';
    els.report.style.display='none';
    els.journeyTitle.textContent=`${startName} ‚Üí ${endName} ‚Ä¢ t√•g ${state.trainNumber||'‚Äì'}`;
    els.journeyMsg.style.display='none';
    renderRouteCards();
    requestGpsWatch();

    if(state.trainNumber){
      showJourneyMessage('H√§mtar tidtabell fr√•n Trafikverket‚Ä¶', false);
      const result = await fetchTimetable(state.trainNumber, state.startedAt);
      if(result.success){
        applyTimetableToRoute(result.timetable);
        filterRouteByTimetable(result.stationStops);
        renderRouteCards();
        const stopCount = state.route.filter(s => s.shouldStop).length;
        showJourneyMessage(`Tidtabell h√§mtad! (${stopCount} stopp)`, false);
        setTimeout(() => { els.journeyMsg.style.display='none'; }, 3000);
      } else {
        showJourneyMessage(`Tidtabell: ${result.error}`, true);
        setTimeout(() => { els.journeyMsg.style.display='none'; }, 8000);
      }
    }
  }

  function requestGpsWatch(){
    if(!navigator.geolocation){
      updateGpsStatus(null, { message:'GPS saknas i webbl√§saren.' });
      showJourneyMessage('GPS st√∂ds inte i den h√§r webbl√§saren.', true);
      return;
    }
    if(state.watchId!==null) navigator.geolocation.clearWatch(state.watchId);
    const startWatch=()=>{
      state.watchId = navigator.geolocation.watchPosition(handlePosition, handlePositionError, {
        enableHighAccuracy:true,
        maximumAge:1000,
        timeout:15000
      });
      updateGpsStatus(null, { message:'V√§ntar p√• f√∂rsta fix‚Ä¶' });
    };
    navigator.geolocation.getCurrentPosition(pos=>{
      state.lastPosition=pos;
      state.lastFixTime=Date.now();
      updateGpsStatus(pos);
      startWatch();
    }, err=>{
      if(err && err.code===err.PERMISSION_DENIED){
        updateGpsStatus(null, { message:'Plats nekad ‚Äì till√•t GPS i webbl√§saren.' });
        showJourneyMessage('Till√•t plats/GPS f√∂r den h√§r sidan och starta om.', true);
        return;
      }
      startWatch();
    }, { enableHighAccuracy:true, maximumAge:1000, timeout:8000 });
  }

  function handlePosition(pos){
    state.lastPosition=pos;
    state.lastFixTime=Date.now();
    updateGpsStatus(pos);
    if(!state.running) return;
    const lat=pos.coords.latitude;
    const lon=pos.coords.longitude;
    const acc=pos.coords.accuracy;
    const speed=pos.coords.speed!=null?pos.coords.speed:estimateSpeedFromHistory(pos);
    state.lastSpeed=speed;
    state.lastSpeedTime=pos.timestamp||Date.now();
    updateSpeedReadout(speed, acc);
    if(!state.route.length) return;
    const idxs=candidateIndices();
    idxs.forEach(idx=>{
      const station=state.route[idx];
      if(!station||station.lat==null||station.lon==null) return;
      const dist=haversine(lat,lon,station.lat,station.lon);
      station.lastSeenDistance=dist;
      evaluateGeofence(idx, dist);
      trackClosestApproach(idx);
    });
    processSpeedTriggers(speed);
    renderRouteCards();
  }

  const speedHistory=[];
  function estimateSpeedFromHistory(pos){
    const now=pos.timestamp||Date.now();
    speedHistory.push({
      lat:pos.coords.latitude,
      lon:pos.coords.longitude,
      t:now
    });
    while(speedHistory.length>10) speedHistory.shift();
    if(speedHistory.length<2) return null;
    const a=speedHistory[speedHistory.length-2];
    const b=speedHistory[speedHistory.length-1];
    const dt=(b.t-a.t)/1000;
    if(dt<=0) return null;
    const dist=haversine(a.lat,a.lon,b.lat,b.lon);
    return dist/dt;
  }

  function updateSpeedReadout(speed, accuracy){
    if(speed!=null){
      els.gpsSpeed.textContent=`${(speed*3.6).toFixed(1)} km/h`;
      if(speed<0.5){
        els.gpsExtra.textContent='Stillast√•ende (under 0,5 km/h)';
      }else if(speed<5){
        els.gpsExtra.textContent='L√•g fart ‚Äì m√∂jlig inbromsning eller avg√•ng';
      }else{
        els.gpsExtra.textContent='I r√∂relse';
      }
    }else{
      els.gpsSpeed.textContent='‚Äì';
      els.gpsExtra.textContent='Hastighet saknas i GPS-datat';
    }
    if(accuracy!=null){
      els.gpsAccuracy.textContent=`Noggrannhet: ¬±${Math.round(accuracy)} m`;
    }
  }

  function handlePositionError(err){
    updateGpsStatus(null, err);
    let msg = 'Kunde inte l√§sa GPS.';
    if(err){
      switch(err.code){
        case 1: msg = 'GPS-√•tkomst nekad ‚Äì aktivera platsbeh√∂righet'; break;
        case 2: msg = 'GPS-signal otillg√§nglig ‚Äì f√∂rs√∂k utomhus'; break;
        case 3: msg = 'GPS timeout ‚Äì f√∂rs√∂ker igen...'; break;
        default: msg = err.message || msg;
      }
    }
    showJourneyMessage(msg, true);
  }

  function updateGpsStatus(pos, error){
    if(pos){
      els.gpsStatusBadge.textContent='GPS aktiv';
      els.gpsStatusBadge.classList.add('live');
      els.gpsStatusBadge.classList.remove('warn');
      els.gpsStatusText.textContent='Signal mottagen';
      els.gpsCoords.textContent=`${pos.coords.latitude.toFixed(5)}, ${pos.coords.longitude.toFixed(5)}`;
      const ts=new Date(pos.timestamp||Date.now());
      els.gpsTimestamp.textContent=ts.toLocaleTimeString('sv-SE');
    }else if(error){
      els.gpsStatusBadge.textContent='GPS saknas';
      els.gpsStatusBadge.classList.add('warn');
      els.gpsStatusText.textContent=error.message||'Ingen GPS';
      els.gpsCoords.textContent='‚Äì';
      els.gpsTimestamp.textContent='‚Äì';
    }else{
      els.gpsStatusBadge.textContent='Ingen GPS √§nnu';
      els.gpsStatusBadge.classList.remove('warn','live');
      els.gpsStatusText.textContent='V√§ntar p√• position‚Ä¶';
      els.gpsCoords.textContent='‚Äì';
      els.gpsTimestamp.textContent='‚Äì';
    }
  }

  function candidateIndices(){
    if(!state.route.length) return [];
    const idxs=new Set();
    idxs.add(Math.max(0,state.lastReachedIndex-1));
    idxs.add(state.lastReachedIndex);
    if(state.nextIndex!=null) idxs.add(state.nextIndex);
    if(state.nextIndex!=null && state.nextIndex+1<state.route.length) idxs.add(state.nextIndex+1);
    return Array.from(idxs).filter(i=>i>=0 && i<state.route.length);
  }

  function evaluateGeofence(idx, distance){
    const station=state.route[idx];
    if(!station) return;
    const radius=station.radius||DEFAULT_RADIUS;
    const exitMargin=station.customRadius?0:EXTRA_MARGIN;
    const exitThreshold=radius+exitMargin;
    if(distance<=radius){
      if(!station.inZone){
        station.inZone=true;
        handleStationEntry(idx);
      }
    }else if(station.inZone && distance>exitThreshold){
      station.inZone=false;
      handleStationExit(idx);
    }
  }

  function trackClosestApproach(idx){
    const station=state.route[idx];
    if(!station||!station.shouldStop||!station.actualArrival||station.actualDeparture) return;
    if(!station.inZone) return;
    const dist=station.lastSeenDistance;
    if(dist==null) return;
    const pos=state.lastPosition;
    const now=new Date();
    if(station.closestDistance==null || dist<station.closestDistance-CLOSE_APPROACH_EPS){
      station.closestDistance=dist;
      station.closestTime=now;
      station.closestPosition=pos?{
        lat:pos.coords.latitude,
        lon:pos.coords.longitude,
        accuracy:pos.coords.accuracy||null
      }:null;
      if(station.needsArrivalRetiming){
        station.actualArrival=new Date(now);
        station.arrivalSource='gps';
        station.arrivalPosition=station.closestPosition;
      }
    }else if(station.needsArrivalRetiming && station.closestDistance!=null && dist>station.closestDistance+PASS_DISTANCE_MARGIN){
      // Markera passering endast om vi r√∂r oss i h√∂g fart (inte bromsar)
      const speed = state.lastSpeed;
      const clearlyPassing = typeof speed === 'number' && speed > SPEED_THRESHOLD_MS * 2; // >10 km/h
      if(clearlyPassing){
        markPassingDeparture(idx);
      }
    }
  }

  function markPassingDeparture(idx){
    const station=state.route[idx];
    if(!station||station.actualDeparture) return;
    const pos=state.lastPosition;
    station.actualDeparture=new Date();
    station.departSource='gps-pass';
    station.departurePosition=pos?{
      lat:pos.coords.latitude,
      lon:pos.coords.longitude,
      accuracy:pos.coords.accuracy||null
    }:null;
    station.needsArrivalRetiming=false;
    station.reachedLowSpeed=false;
    station.departureProvisional=false;
    station.departureProvisionalAt=null;
    advanceAfterDeparture(idx);
  }

  function processSpeedTriggers(speed){
    if(typeof speed!=='number') return;
    const lastIdx=state.route.length?state.route.length-1:null;
    if(state.running && lastIdx!=null){
      const endStation=state.route[lastIdx];
      if(endStation && endStation.shouldStop && endStation.actualArrival && !endStation.actualDeparture && endStation.inZone && speed<=SPEED_THRESHOLD_MS){
        stopJourney(false, 'Slutstation registrerad ‚Äì stillast√•ende');
        return;
      }
    }
    const candidates=[];
    if(state.awaitingDepartureIndex!=null) candidates.push(state.awaitingDepartureIndex);
    if(state.departureProvisionalIdx!=null) candidates.push(state.departureProvisionalIdx);
    const seen=new Set();
    for(const idx of candidates){
      if(seen.has(idx)) continue;
      seen.add(idx);
      const station=state.route[idx];
      const allowNoArrivalAtStart = idx===0 && !station.actualArrival;
      if(!station||!station.shouldStop||(!station.actualArrival && !allowNoArrivalAtStart)) continue;
      const pos=state.lastPosition;
      const now=Date.now();
      if(station.actualDeparture && station.departureProvisional){
        const withinDist = station.lastSeenDistance!=null ? station.lastSeenDistance <= (station.radius||DEFAULT_RADIUS) + EXTRA_MARGIN*2 : true;
        const withinTime = !station.departureProvisionalAt || (now - station.departureProvisionalAt) <= DEPART_REVERT_WINDOW_MS;
        if(speed<=SPEED_THRESHOLD_MS && (withinDist || withinTime)){
          station.actualDeparture=null;
          station.departSource='';
          station.departurePosition=null;
          station.departureProvisional=false;
          station.departureProvisionalAt=null;
          state.awaitingDepartureIndex=idx;
          state.departureProvisionalIdx=null;
          station.reachedLowSpeed=true;
          state.lastReachedIndex=idx;
          state.nextIndex=idx+1<state.route.length?idx+1:null;
          updateNextStopUI();
          renderRouteCards();
          continue;
        }
        const farAway = station.lastSeenDistance!=null && station.lastSeenDistance > (station.radius||DEFAULT_RADIUS) + EXTRA_MARGIN*3;
        if(!withinTime || farAway){
          station.departureProvisional=false;
          station.departureProvisionalAt=null;
          if(state.departureProvisionalIdx===idx) state.departureProvisionalIdx=null;
        }
        continue;
      }
      if(!station.actualArrival && !allowNoArrivalAtStart) continue;
      if(station.actualDeparture) continue;
      if(station.needsArrivalRetiming && !station.inZone){
        station.needsArrivalRetiming=false;
      }
      if(station.needsArrivalRetiming && station.inZone && speed<=SPEED_THRESHOLD_MS){
        station.actualArrival=new Date();
        station.arrivalSource='gps';
        station.arrivalPosition=pos?{
          lat:pos.coords.latitude,
        lon:pos.coords.longitude,
        accuracy:pos.coords.accuracy||null
      }:null;
      station.needsArrivalRetiming=false;
      station.reachedLowSpeed=true;
    }else if(!station.reachedLowSpeed && speed<=SPEED_THRESHOLD_MS){
      station.reachedLowSpeed=true;
    }
    if(station.reachedLowSpeed && speed>=SPEED_THRESHOLD_MS){
      station.actualDeparture=new Date();
      station.departSource='gps';
      station.departurePosition=pos?{
        lat:pos.coords.latitude,
        lon:pos.coords.longitude,
        accuracy:pos.coords.accuracy||null
      }:null;
      station.departureProvisional=false;
      station.departureProvisionalAt=null;
      if(state.departureProvisionalIdx===idx) state.departureProvisionalIdx=null;
      advanceAfterDeparture(idx);
    }
    }
  }

  function handleStationEntry(idx){
    const station=state.route[idx];
    const pos=state.lastPosition;
    const posInfo=pos?{
      lat:pos.coords.latitude,
      lon:pos.coords.longitude,
      accuracy:pos.coords.accuracy||null
    }:null;
    const isStartStation = idx===0;
    if(isStartStation && !station.actualArrival && !station.actualDeparture){
      state.lastReachedIndex=idx;
      state.nextIndex=idx+1<state.route.length?idx+1:null;
      if(station.shouldStop){
        state.awaitingDepartureIndex=idx;
        const slowNow=typeof state.lastSpeed==='number' && state.lastSpeed<=SPEED_THRESHOLD_MS;
        station.reachedLowSpeed=slowNow;
        station.needsArrivalRetiming=false;
        station.closestDistance=station.lastSeenDistance!=null?station.lastSeenDistance:null;
        station.closestTime=new Date();
        station.closestPosition=posInfo;
      }
      updateNextStopUI();
      return;
    }
    if(!station.actualArrival){
      station.actualArrival=new Date();
      station.arrivalSource='gps';
      station.arrivalPosition=posInfo;
      state.lastReachedIndex=idx;
      state.nextIndex=idx+1<state.route.length?idx+1:null;
      vibrate([100, 50, 100]); // Double pulse for arrival
      updateNextStopUI();
    }
    if(!station.shouldStop){
      recordImmediatePass(idx);
    }else{
      state.awaitingDepartureIndex=idx;
      const slowNow=typeof state.lastSpeed==='number' && state.lastSpeed<=SPEED_THRESHOLD_MS;
      station.reachedLowSpeed=slowNow;
      station.needsArrivalRetiming=!slowNow;
      station.closestDistance=station.lastSeenDistance!=null?station.lastSeenDistance:null;
      station.closestTime=new Date();
      station.closestPosition=posInfo;
      if(idx===state.route.length-1){
        // sista station: inv√§nta stillast√•ende innan vi avslutar
        state.awaitingDepartureIndex=null;
      }
    }
  }

  function recordImmediatePass(idx){
    const station=state.route[idx];
    if(!station) return;
    station.passThrough=true;
    if(!station.actualDeparture){
      station.actualDeparture=new Date();
      station.departSource='gps-pass';
      station.departurePosition=station.arrivalPosition;
      station.departureProvisional=false;
      station.departureProvisionalAt=null;
    }
    advanceAfterDeparture(idx);
  }

  function handleStationExit(idx){
    const station=state.route[idx];
    if(!station.shouldStop) return;
    if(idx===state.route.length-1) return; // sista station: avslutas f√∂rst vid stillast√•ende
    const allowStartDeparture = idx===0 && !station.actualArrival;
    if((station.actualArrival || allowStartDeparture) && !station.actualDeparture){
      const pos=state.lastPosition;
      const speed=state.lastSpeed;
      const movingFast=typeof speed==='number' && speed>SPEED_THRESHOLD_MS;
      // Om vi inte har stannat √§nnu och r√∂r oss l√•ngsamt √§r det troligen GPS-fluktuation
      // under inbromsning - v√§nta tills vi antingen stannar eller tydligt passerar
      if(!station.reachedLowSpeed && !movingFast){
        return;
      }
      station.actualDeparture=new Date();
      station.departSource='gps';
      station.departurePosition=pos?{
        lat:pos.coords.latitude,
        lon:pos.coords.longitude,
        accuracy:pos.coords.accuracy||null
      }:null;
      station.needsArrivalRetiming=false;
      station.reachedLowSpeed=true;
      station.departureProvisional=station.shouldStop && movingFast;
      station.departureProvisionalAt=station.departureProvisional?Date.now():null;
      if(station.departureProvisional){
        state.departureProvisionalIdx=idx;
      }
      advanceAfterDeparture(idx);
      if(station.departureProvisional){
        state.awaitingDepartureIndex=idx;
      }
    }
  }

  function advanceAfterDeparture(idx){
    state.lastReachedIndex=Math.max(state.lastReachedIndex, idx);
    state.nextIndex=idx+1<state.route.length?idx+1:null;
    if(state.awaitingDepartureIndex===idx){
      state.awaitingDepartureIndex=null;
    }
    const station=state.route[idx];
    if(station){
      station.needsArrivalRetiming=false;
      if(!station.departureProvisional){
        station.departureProvisionalAt=null;
        vibrate(200); // Single pulse for confirmed departure
      }
    }
    updateNextStopUI();
    if(idx===state.route.length-1){
      stopJourney(false, 'Slutstation klar');
    }else{
      scrollToNextStation();
    }
  }

  function scrollToNextStation(){
    if(state.nextIndex===null) return;
    setTimeout(()=>{
      const cards=els.cards.querySelectorAll('.card');
      const nextCard=cards[state.nextIndex];
      if(nextCard){
        nextCard.scrollIntoView({
          behavior:'smooth',
          block:'center'
        });
      }
    }, 500);
  }

  function updateNextStopUI(){
    if(state.nextIndex==null){
      els.nextStop.textContent='‚Äì';
      els.nextStopInfo.textContent='Alla stationer registrerade';
    }else{
      const st=state.route[state.nextIndex];
      els.nextStop.textContent=st.name;
      const dist=st.lastSeenDistance;
      els.nextStopInfo.textContent = dist!=null ? `‚âà${formatDistance(dist)} bort` : 'Ingen distansdata √§nnu';
    }
  }

  function renderRouteCards(){
    const cardsHtml=state.route.map((station,idx)=>{
      const arrival=station.actualArrival?formatTime(station.actualArrival):'‚Äì';
      const depart=station.actualDeparture?formatTime(station.actualDeparture):'‚Äì';
      const dist=station.lastSeenDistance!=null?formatDistance(station.lastSeenDistance):'‚Äì';
      const classes=['card'];
      if(state.nextIndex===idx) classes.push('active');

      const schedArr = station.scheduledArrival ? formatTime(station.scheduledArrival) : null;
      const schedDep = station.scheduledDeparture ? formatTime(station.scheduledDeparture) : null;

      let arrDelayBadge = '';
      let depDelayBadge = '';

      if(station.actualArrival && station.scheduledArrival){
        const delayMin = Math.round((new Date(station.actualArrival) - new Date(station.scheduledArrival)) / 60000);
        const absDelay = Math.abs(delayMin);
        let badgeClass = '';
        let delayText = '';

        if(delayMin < -1){
          badgeClass = 'early';
          delayText = `${absDelay} min tidig`;
        } else if(delayMin > 1 && delayMin <= 5){
          badgeClass = 'late';
          delayText = `+${delayMin} min`;
        } else if(delayMin > 5){
          badgeClass = 'very-late';
          delayText = `+${delayMin} min`;
        } else {
          badgeClass = 'live';
          delayText = 'I tid';
        }

        arrDelayBadge = ` <span class="badge ${badgeClass}">${delayText}</span>`;
      }

      if(station.actualDeparture && station.scheduledDeparture){
        const delayMin = Math.round((new Date(station.actualDeparture) - new Date(station.scheduledDeparture)) / 60000);
        const absDelay = Math.abs(delayMin);
        let badgeClass = '';
        let delayText = '';

        if(delayMin < -1){
          badgeClass = 'early';
          delayText = `${absDelay} min tidig`;
        } else if(delayMin > 1 && delayMin <= 5){
          badgeClass = 'late';
          delayText = `+${delayMin} min`;
        } else if(delayMin > 5){
          badgeClass = 'very-late';
          delayText = `+${delayMin} min`;
        } else {
          badgeClass = 'live';
          delayText = 'I tid';
        }

        depDelayBadge = ` <span class="badge ${badgeClass}">${delayText}</span>`;
      }

      const isDone = station.actualArrival && station.actualDeparture;
      if(isDone) classes.push('done');
      const stopIcon = station.shouldStop ? '' : ' ‚è©';

      return `<div class="${classes.join(' ')}" data-idx="${idx}">
        <div class="card-header" data-action="toggle-expand" data-idx="${idx}">
          <div>
            <h3><span class="station-num">${station.order}</span>${station.name}${stopIcon}</h3>
            <div class="card-times">
              <span class="arr"><strong>${arrival}</strong>${arrDelayBadge}</span>
              <span class="dep"><strong>${depart}</strong>${depDelayBadge}</span>
            </div>
          </div>
          <div style="display:flex;align-items:center;gap:.4rem">
            <span class="badge dist">${dist}</span>
            <span class="card-toggle">‚ñº</span>
          </div>
        </div>
        <div class="card-expand">
          <div class="card-expand-inner">
            ${schedArr ? `<p class="scheduled">Ank schema: ${schedArr}</p>` : ''}
            ${schedDep ? `<p class="scheduled">Avg schema: ${schedDep}</p>` : ''}
            <p class="meta">${Math.round(station.radius)} m radie ‚Ä¢ ${station.lat!=null?station.lat.toFixed(4):'‚Äì'}, ${station.lon!=null?station.lon.toFixed(4):'‚Äì'}</p>
            <div class="control-row">
              <label><input type="checkbox" data-action="toggle-stop" data-idx="${idx}" ${station.shouldStop?'checked':''}> Planerat stopp</label>
            </div>
            <div class="control-row">
              <label><input type="checkbox" data-action="exclude-run" data-idx="${idx}" ${station.excludeInboundRun?'checked':''}> Exkludera g√•ngtid</label>
            </div>
            <div class="bar card-actions">
              <button class="ghost sm" data-action="arrive" data-idx="${idx}">‚Üì Ankomst</button>
              <button class="ghost sm" data-action="depart" data-idx="${idx}">‚Üë Avg√•ng</button>
              <button class="ghost sm" data-action="update-pos" data-idx="${idx}">üìç Uppdatera pos</button>
            </div>
          </div>
        </div>
      </div>`;
    }).join('');
    els.cards.innerHTML=cardsHtml;
    updateNextStopUI();
  }

  function formatTime(dt){
    return new Date(dt).toLocaleTimeString('sv-SE',{hour:'2-digit',minute:'2-digit',second:'2-digit'});
  }

  function formatDistance(meters){
    if(meters>1000) return (meters/1000).toFixed(2)+' km';
    return Math.round(meters)+' m';
  }

  function handleCardButton(ev){
    // Handle card header toggle
    const header=ev.target.closest('[data-action="toggle-expand"]');
    if(header){
      const card=header.closest('.card');
      if(card) card.classList.toggle('expanded');
      return;
    }
    const btn=ev.target.closest('button[data-action]');
    if(!btn) return;
    const idx=parseInt(btn.dataset.idx,10);
    if(Number.isNaN(idx) || !state.route[idx]) return;
    if(btn.dataset.action==='arrive'){
      manualArrival(idx);
    }else if(btn.dataset.action==='depart'){
      manualDeparture(idx);
    }else if(btn.dataset.action==='update-pos'){
      const station=state.route[idx];
      if(!station) return;
      calibrateWithCurrentPosition(station.name, true);
    }
  }

  function handleCardChange(ev){
    const target=ev.target;
    const action=target.dataset.action;
    if(action==='toggle-stop'){
      const idx=parseInt(target.dataset.idx,10);
      if(!state.route[idx]) return;
      state.route[idx].shouldStop=target.checked;
      if(!target.checked && state.awaitingDepartureIndex===idx){
        state.awaitingDepartureIndex=null;
      }
      renderRouteCards();
    }else if(action==='exclude-run'){
      const idx=parseInt(target.dataset.idx,10);
      if(!state.route[idx]) return;
      state.route[idx].excludeInboundRun=target.checked;
    }
  }

  function manualArrival(idx){
    const station=state.route[idx];
    if(!station) return;
    station.actualArrival=new Date();
    station.arrivalSource='manual';
    vibrate([100, 50, 100]); // Double pulse for arrival
    station.arrivalPosition=state.lastPosition?{
      lat:state.lastPosition.coords.latitude,
      lon:state.lastPosition.coords.longitude,
      accuracy:state.lastPosition.coords.accuracy||null
    }:null;
    station.inZone=true;
    station.needsArrivalRetiming=false;
    station.reachedLowSpeed=true;
    state.lastReachedIndex=idx;
    state.nextIndex=idx+1<state.route.length?idx+1:null;
    if(station.shouldStop){
      state.awaitingDepartureIndex=idx;
    }
    renderRouteCards();
  }

  function manualDeparture(idx){
    const station=state.route[idx];
    if(!station) return;
    station.actualDeparture=new Date();
    station.departSource='manual';
    vibrate(200); // Single pulse for departure
    station.departurePosition=state.lastPosition?{
      lat:state.lastPosition.coords.latitude,
      lon:state.lastPosition.coords.longitude,
      accuracy:state.lastPosition.coords.accuracy||null
    }:null;
    station.needsArrivalRetiming=false;
    station.reachedLowSpeed=true;
    station.departureProvisional=false;
    station.departureProvisionalAt=null;
    if(state.departureProvisionalIdx===idx) state.departureProvisionalIdx=null;
    advanceAfterDeparture(idx);
    renderRouteCards();
  }

  function stopJourney(aborted, reason){
    if(!state.route.length) return;
    if(state.watchId!==null){
      navigator.geolocation.clearWatch(state.watchId);
      state.watchId=null;
    }
    state.running=false;
    state.aborted=!!aborted;
    state.autoReason=reason||'';
    state.departureProvisionalIdx=null;
    els.journeyMsg.textContent=reason|| (aborted?'Resan avslutad':'Resan sparad');
    els.journeyMsg.style.display='inline-block';
    const logEntry=saveLog(aborted);
    renderReport(logEntry);
    els.journey.style.display='none';
    els.report.style.display='block';
    els.setup.style.display='block';
  }

  function renderReport(logEntry){
    if(!logEntry){
      els.reportHTML.innerHTML='<p>Ingen data att visa.</p>';
      return;
    }
    const rows=logEntry.stops.map((st,idx)=>{
      const dwell=st.actualArrival&&st.actualDeparture?((new Date(st.actualDeparture)-new Date(st.actualArrival))/60000).toFixed(1)+' min':'‚Äì';

      let arrDelay = '‚Äì';
      if(st.actualArrival && st.scheduledArrival){
        const delayMin = Math.round((new Date(st.actualArrival) - new Date(st.scheduledArrival)) / 60000);
        if(delayMin < -1){
          arrDelay = `${Math.abs(delayMin)} min tidig`;
        } else if(delayMin > 1){
          arrDelay = `+${delayMin} min`;
        } else {
          arrDelay = 'I tid';
        }
      }

      let depDelay = '‚Äì';
      if(st.actualDeparture && st.scheduledDeparture){
        const delayMin = Math.round((new Date(st.actualDeparture) - new Date(st.scheduledDeparture)) / 60000);
        if(delayMin < -1){
          depDelay = `${Math.abs(delayMin)} min tidig`;
        } else if(delayMin > 1){
          depDelay = `+${delayMin} min`;
        } else {
          depDelay = 'I tid';
        }
      }

      return `<tr>
        <td>${idx+1}</td>
        <td>${st.name}</td>
        <td>${st.actualArrival?formatTime(st.actualArrival):'‚Äì'}${st.scheduledArrival?`<br><span class="meta">Schema: ${formatTime(st.scheduledArrival)}</span>`:''}</td>
        <td>${st.actualDeparture?formatTime(st.actualDeparture):'‚Äì'}${st.scheduledDeparture?`<br><span class="meta">Schema: ${formatTime(st.scheduledDeparture)}</span>`:''}</td>
        <td>${dwell}</td>
        <td>${arrDelay}</td>
        <td>${depDelay}</td>
      </tr>`;
    }).join('');
    els.reportHTML.innerHTML=`
      <p><strong>T√•g:</strong> ${logEntry.trainNumber||'‚Äì'} ‚Ä¢ <strong>Str√§cka:</strong> ${logEntry.startStation} ‚Üí ${logEntry.endStation}</p>
      <p><strong>Start:</strong> ${logEntry.startedAt?new Date(logEntry.startedAt).toLocaleString('sv-SE'):'‚Äì'} ‚Ä¢ <strong>Slut:</strong> ${logEntry.finishedAt?new Date(logEntry.finishedAt).toLocaleString('sv-SE'):'‚Äì'}</p>
      ${logEntry.notes?`<p><strong>Anteckningar:</strong> ${escapeHtml(logEntry.notes)}</p>`:''}
      <div class="table-wrap">
        <table>
          <thead>
            <tr><th>#</th><th>Station</th><th>Ankomst</th><th>Avg√•ng</th><th>Uppeh√•ll</th><th>F√∂rseningank</th><th>F√∂rseningavg</th></tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      </div>
      <p>${state.aborted?'Status: Avbruten':'Status: Klar'}${state.autoReason?` ‚Äì ${state.autoReason}`:''}</p>
    `;
  }

  function saveLog(aborted){
    const logs=loadLogs();
    const entry={
      id:Date.now().toString(36),
      trainNumber:state.trainNumber,
      startStation:state.route[0]?.name||'',
      endStation:state.route[state.route.length-1]?.name||'',
      startedAt:state.startedAt,
      finishedAt:new Date(),
      aborted:!!aborted,
      notes:state.notes,
      stops:state.route.map(st=>({
        name:st.name,
        actualArrival:st.actualArrival,
        actualDeparture:st.actualDeparture,
        scheduledArrival:st.scheduledArrival,
        scheduledDeparture:st.scheduledDeparture,
        arrivalSource:st.arrivalSource,
        departSource:st.departSource,
        shouldStop:st.shouldStop,
        excludeInboundRun:!!st.excludeInboundRun
      }))
    };
    logs.push(entry);
    try{
      localStorage.setItem(STORAGE_KEY_LOGS, JSON.stringify(logs));
    }catch(e){}
    updateLogCount();

    if(entry.trainNumber && entry.startStation && entry.endStation) {
      updateRouteHistory(entry.trainNumber, entry.startStation, entry.endStation);
    }

    return entry;
  }

  function loadLogs(){
    try{
      const raw=localStorage.getItem(STORAGE_KEY_LOGS);
      if(!raw) return [];
      const parsed=JSON.parse(raw);
      if(!Array.isArray(parsed)) return [];
      return parsed.map(normalizeLogEntry).filter(Boolean);
    }catch(e){
      return [];
    }
  }

  function loadRouteHistory(){
    try{
      const raw=localStorage.getItem(STORAGE_KEY_ROUTE_HISTORY);
      if(!raw) return {};
      const parsed=JSON.parse(raw);
      return parsed && typeof parsed==='object' ? parsed : {};
    }catch(e){
      console.error('Kunde ej ladda rutt-historik:', e);
      return {};
    }
  }

  function saveRouteHistory(history){
    try{
      localStorage.setItem(STORAGE_KEY_ROUTE_HISTORY, JSON.stringify(history));
    }catch(e){
      console.error('Kunde ej spara rutt-historik:', e);
    }
  }

  function updateRouteHistory(trainNumber, startStation, endStation){
    if(!trainNumber || !startStation || !endStation) return;

    const history = loadRouteHistory();
    if(!history[trainNumber]) {
      history[trainNumber] = [];
    }

    const now = new Date();
    history[trainNumber].push({
      start: startStation,
      end: endStation,
      timestamp: now.toISOString(),
      hour: now.getHours(),
      minute: now.getMinutes()
    });

    if(history[trainNumber].length > 100) {
      history[trainNumber] = history[trainNumber].slice(-100);
    }

    saveRouteHistory(history);
  }

  function analyzeRouteHistory(trainNumber, currentHour){
    if(!trainNumber) return null;

    const history = loadRouteHistory();
    const routes = history[trainNumber];

    if(!routes || routes.length === 0) return null;

    const routeCounts = {};
    const TIME_WINDOW = 2;

    routes.forEach(r => {
      const key = `${r.start}|${r.end}`;
      if(!routeCounts[key]) {
        routeCounts[key] = { start: r.start, end: r.end, count: 0, timeMatch: 0 };
      }
      routeCounts[key].count++;

      if(currentHour !== undefined && r.hour !== undefined) {
        const timeDiff = Math.abs(r.hour - currentHour);
        if(timeDiff <= TIME_WINDOW) {
          routeCounts[key].timeMatch++;
        }
      }
    });

    const sorted = Object.values(routeCounts).sort((a, b) => {
      if(currentHour !== undefined && (a.timeMatch > 0 || b.timeMatch > 0)) {
        if(a.timeMatch !== b.timeMatch) return b.timeMatch - a.timeMatch;
      }
      return b.count - a.count;
    });

    return sorted[0] || null;
  }

  async function handleTrainNumberInput(e){
    const trainNumber = e.target.value.trim();

    if(!trainNumber || trainNumber.length < 2) {
      document.getElementById('routeSuggestion').style.display='none';
      currentSuggestion = null;
      return;
    }

    setTimeout(async () => {
      const currentTime = new Date();
      const currentHour = currentTime.getHours();
      const currentMinute = currentTime.getMinutes();

      let suggestion = null;
      let suggestionSource = '';

      const timetableResult = await fetchTimetable(trainNumber, currentTime);

      if(timetableResult.success && timetableResult.timetable) {
        const nearestStation = await findNearestStation();
        const timeBasedRoute = findCurrentRouteSegment(
          timetableResult.timetable,
          nearestStation,
          currentHour,
          currentMinute
        );

        if(timeBasedRoute) {
          suggestion = {
            start: timeBasedRoute.start,
            end: timeBasedRoute.end,
            count: 0
          };
          suggestionSource = `GPS + tidtabell (${timeBasedRoute.startTime})`;
        }
      }

      if(!suggestion) {
        const historySuggestion = analyzeRouteHistory(trainNumber, currentHour);
        if(historySuggestion && historySuggestion.count >= 1) {
          suggestion = historySuggestion;
          suggestionSource = historySuggestion.count === 1
            ? '1 tidigare k√∂rning'
            : `${historySuggestion.count} tidigare k√∂rningar`;
        }
      }

      if(suggestion) {
        currentSuggestion = suggestion;
        const text = `T√•g ${trainNumber}: ${suggestion.start} ‚Üí ${suggestion.end}`;

        document.getElementById('suggestionText').innerHTML =
          `<strong style="font-size:1.1rem">${text}</strong><br><span style="color:#718096;font-size:.9rem">${suggestionSource}</span>`;
        document.getElementById('routeSuggestion').style.display='block';
      } else {
        document.getElementById('routeSuggestion').style.display='none';
        currentSuggestion = null;
      }
    }, 300);
  }

  function acceptSuggestion(){
    if(!currentSuggestion) return;

    els.startSel.value = currentSuggestion.start;
    els.endSel.value = currentSuggestion.end;
    document.getElementById('routeSuggestion').style.display='none';

    const msg = document.createElement('div');
    msg.style.cssText = 'position:fixed;top:80px;left:50%;transform:translateX(-50%);background:#48bb78;color:white;padding:.8rem 1.5rem;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.15);z-index:1000;font-weight:600;';
    msg.textContent = `‚úì Rutt vald: ${currentSuggestion.start} ‚Üí ${currentSuggestion.end}`;
    document.body.appendChild(msg);
    setTimeout(() => msg.remove(), 2500);
  }

  async function findNearestStation(){
    return new Promise((resolve) => {
      if(!navigator.geolocation) {
        resolve(null);
        return;
      }

      navigator.geolocation.getCurrentPosition(
        (position) => {
          const userLat = position.coords.latitude;
          const userLon = position.coords.longitude;

          let nearest = null;
          let minDistance = Infinity;

          stationCatalog.forEach(station => {
            const dist = haversine(userLat, userLon, station.lat, station.lon);
            if(dist < minDistance) {
              minDistance = dist;
              nearest = station.name;
            }
          });

          resolve(nearest);
        },
        (error) => {
          resolve(null);
        },
        { timeout: 5000, maximumAge: 60000 }
      );
    });
  }

  function findCurrentRouteSegment(timetable, nearestStation, currentHour, currentMinute){
    if(!timetable || !nearestStation) return null;

    const currentTimeMinutes = currentHour * 60 + currentMinute;
    const BEFORE_MARGIN = 30;
    const AFTER_MARGIN = 15;

    const nearestSig = stationSignatures[nearestStation];
    if(!nearestSig) return null;

    const stationTimes = timetable[nearestSig];
    if(!stationTimes) return null;

    const departureTime = stationTimes.departure;
    if(!departureTime) return null;

    const depHour = departureTime.getHours();
    const depMinute = departureTime.getMinutes();
    const depTimeMinutes = depHour * 60 + depMinute;

    const timeDiff = currentTimeMinutes - depTimeMinutes;

    if(timeDiff >= -BEFORE_MARGIN && timeDiff <= AFTER_MARGIN) {
      const sortedStations = Object.keys(timetable)
        .map(sig => {
          const info = timetable[sig];
          const time = info.departure || info.arrival;
          return { sig, time, info };
        })
        .filter(s => s.time)
        .sort((a, b) => a.time - b.time);

      const currentStationIndex = sortedStations.findIndex(s => s.sig === nearestSig);
      if(currentStationIndex === -1) return null;

      const startStation = nearestStation;

      let endStation = null;
      for(let i = sortedStations.length - 1; i > currentStationIndex; i--) {
        const sig = sortedStations[i].sig;
        const name = Object.keys(stationSignatures).find(k => stationSignatures[k] === sig);
        if(name) {
          endStation = name;
          break;
        }
      }

      if(!endStation) return null;

      return {
        start: startStation,
        end: endStation,
        startTime: `${String(depHour).padStart(2, '0')}:${String(depMinute).padStart(2, '0')}`
      };
    }

    return null;
  }

  async function syncLogs(){
    if(!('showOpenFilePicker' in window) || !('showSaveFilePicker' in window)){
      alert('Din webbl√§sare saknar fil√•tkomst-API. Anv√§nd Chrome/Edge via https f√∂r att synka eller exportera ist√§llet.');
      return;
    }
    try{
      let handle=null;
      try{
        const result=await window.showOpenFilePicker({
          types:[{description:'JSON-loggar',accept:{'application/json':['.json']}}],
          excludeAcceptAllOption:false,
          multiple:false
        });
        if(result && result[0]) handle=result[0];
      }catch(e){
        if(e && e.name==='AbortError'){
          showHeaderStatus('Synk avbruten ‚Äì ingen fil vald.', true);
          return;
        }
        throw e;
      }
      if(!handle){
        showHeaderStatus('Hittade ingen loggfil. Exportera f√∂rst f√∂r att skapa en fil.', true);
        return;
      }
      const file=await handle.getFile();
      const text=await file.text();
      const fileLogs=(()=>{
        try{ return JSON.parse(text||'[]'); }
        catch(e){ return []; }
      })();
      const incomingRaw=Array.isArray(fileLogs)?fileLogs:(fileLogs?[fileLogs]:[]);
      const normalizedIncoming=incomingRaw.map(normalizeLogEntry).filter(Boolean);
      const existing=loadLogs();
      const merged=dedupeLogs(existing.concat(normalizedIncoming));
      const added=Math.max(merged.length - existing.length, 0);
      const ignored=Math.max(incomingRaw.length - normalizedIncoming.length, 0);
      const writable=await handle.createWritable();
      await writable.write(JSON.stringify(merged,null,2));
      await writable.close();
      try{
        localStorage.setItem(STORAGE_KEY_LOGS, JSON.stringify(merged));
      }catch(e){}
      updateLogCount();
      const message = normalizedIncoming.length
        ? `Synk klar: +${added} / ignorerade ${ignored}`
        : 'Ingen giltig logg hittades i filen.';
      showHeaderStatus(message, !normalizedIncoming.length);
    }catch(err){
      const msg = err && (err.message || err.name) ? `${err.name||''} ${err.message||''}`.trim() : 'Ok√§nt fel';
      showHeaderStatus(`Synk misslyckades: ${msg}`, true);
      console.error(err);
    }
  }

  function exportLogs(){
    const logs=loadLogs();
    const blob=new Blob([JSON.stringify(logs,null,2)],{type:'application/json'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url;
    a.download='kinnekulle_gps_logs.json';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function exportLogsCSV(){
    const logs=loadLogs();
    if(!logs.length){
      showHeaderStatus('Inga loggar att exportera.', true);
      return;
    }
    const rows=[['Datum','T√•g','Fr√•n','Till','Station','Ordning','Ankomst','Avg√•ng','Schema Ank','Schema Avg','F√∂rsenad (min)','K√§lla']];
    logs.forEach(log=>{
      const logDate=log.startedAt?new Date(log.startedAt).toLocaleDateString('sv-SE'):'';
      const trainNum=log.trainNumber||'';
      const fromSt=log.route&&log.route[0]?log.route[0].name:'';
      const toSt=log.route&&log.route.length?log.route[log.route.length-1].name:'';
      (log.route||[]).forEach(st=>{
        const arr=st.actualArrival?new Date(st.actualArrival).toLocaleTimeString('sv-SE'):'';
        const dep=st.actualDeparture?new Date(st.actualDeparture).toLocaleTimeString('sv-SE'):'';
        const schArr=st.scheduledArrival?new Date(st.scheduledArrival).toLocaleTimeString('sv-SE'):'';
        const schDep=st.scheduledDeparture?new Date(st.scheduledDeparture).toLocaleTimeString('sv-SE'):'';
        let delay='';
        if(st.actualArrival&&st.scheduledArrival){
          delay=Math.round((new Date(st.actualArrival)-new Date(st.scheduledArrival))/60000);
        }
        const source=st.arrivalSource||'';
        rows.push([logDate,trainNum,fromSt,toSt,st.name,st.order||'',arr,dep,schArr,schDep,delay,source]);
      });
    });
    const csv=rows.map(r=>r.map(c=>'"'+(c+'').replace(/"/g,'""')+'"').join(';')).join('\n');
    const bom='\uFEFF';
    const blob=new Blob([bom+csv],{type:'text/csv;charset=utf-8'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url;
    a.download='kinnekulle_gps_logs.csv';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  async function saveLogsToFile(){
    const localLogs=loadLogs();
    if(!('showOpenFilePicker' in window)){
      showHeaderStatus('Webbl√§saren saknar fil-API. Anv√§nd Exportera ist√§llet.', true);
      return;
    }
    try{
      let handle=null;
      try{
        const result=await window.showOpenFilePicker({
          types:[{description:'JSON-loggar',accept:{'application/json':['.json']}}],
          excludeAcceptAllOption:false,
          multiple:false
        });
        if(result && result[0]) handle=result[0];
      }catch(e){
        if(e && e.name==='AbortError'){
          showHeaderStatus('Sparande avbr√∂ts.', true);
          return;
        }
        throw e;
      }
      if(!handle){
        showHeaderStatus('Ingen fil vald.', true);
        return;
      }
      let existingText='';
      let incomingArray=[];
      try{
        const file=await handle.getFile();
        existingText=await file.text();
        const parsed=(()=>{
          try{ return JSON.parse(existingText||'[]'); }
          catch(e){ return null; }
        })();
        if(parsed===null){
          showHeaderStatus('Kunde inte l√§sa filen ‚Äì sparar inte.', true);
          return;
        }
        incomingArray=Array.isArray(parsed)?parsed:(parsed?[parsed]:[]);
      }catch(e){
        incomingArray=[];
      }
      const normalizedIncoming=incomingArray.map(normalizeLogEntry).filter(Boolean);
      const merged=dedupeLogs(localLogs.concat(normalizedIncoming));
      if(!merged.length){
        showHeaderStatus('Inga loggar att spara ‚Äì ingen skrivning gjordes.', true);
        return;
      }
      const writable=await handle.createWritable();
      await writable.write(JSON.stringify(merged,null,2));
      await writable.close();
      try{
        localStorage.setItem(STORAGE_KEY_LOGS, JSON.stringify(merged));
      }catch(e){}
      updateLogCount();
      showHeaderStatus(`Sparat & synkat: ${merged.length} loggar`, false);
    }catch(err){
      if(err && err.name==='AbortError'){
        showHeaderStatus('Sparande avbr√∂ts.', true);
        return;
      }
      const msg=err && (err.message||err.name)?`${err.name||''} ${err.message||''}`.trim():'Kunde inte spara';
      showHeaderStatus(msg, true);
    }
  }

  function clearLogs(){
    if(!confirm('Vill du ta bort alla sparade k√∂rningar?')) return;
    localStorage.removeItem(STORAGE_KEY_LOGS);
    updateLogCount();
  }

  function updateLogCount(){
    const count=loadLogs().length;
    els.logCountTop.textContent=`Loggar: ${count}`;
  }

  function renderCalibrationTable(){
    stationCatalog=composeStationCatalog();
    populateStationSelects(true);
    const rows=stationCatalog.map(st=>{
      return `<tr data-name="${st.name}">
        <td>${st.name}</td>
        <td><input type="number" step="0.000001" data-field="lat" value="${st.lat!=null?st.lat.toFixed(6):''}" placeholder="lat"></td>
        <td><input type="number" step="0.000001" data-field="lon" value="${st.lon!=null?st.lon.toFixed(6):''}" placeholder="lon"></td>
        <td><input type="number" step="10" data-field="radius" value="${st.radius||DEFAULT_RADIUS}"></td>
        <td><button type="button" class="ghost" data-action="use-current">Anv√§nd min position</button></td>
      </tr>`;
    }).join('');
    els.calibrationBody.innerHTML=rows;
  }

  function handleCalibrationInput(ev){
    const row=ev.target.closest('tr[data-name]');
    if(!row) return;
    const name=row.dataset.name;
    const field=ev.target.dataset.field;
    if(!field) return;
    const value=ev.target.value.trim();
    if(value===''){
      if(stationOverrides[name]){
        delete stationOverrides[name][field];
        if(!Object.keys(stationOverrides[name]).length){
          delete stationOverrides[name];
        }
      }
    }else{
      const num=parseFloat(value);
      if(!stationOverrides[name]) stationOverrides[name]={};
      if(!Number.isNaN(num)){
        stationOverrides[name][field]=num;
      }
    }
    saveStationOverrides();
    stationCatalog=composeStationCatalog();
    renderRouteCards();
  }

  function handleCalibrationClick(ev){
    const btn=ev.target.closest('button[data-action="use-current"]');
    if(!btn) return;
    const row=btn.closest('tr[data-name]');
    if(!row) return;
    const name=row.dataset.name;
    calibrateWithCurrentPosition(name);
  }

  function calibrateWithCurrentPosition(name, updateActiveRoute){
    const applyPosition=pos=>{
      if(!stationOverrides[name]) stationOverrides[name]={};
      stationOverrides[name].lat=pos.coords.latitude;
      stationOverrides[name].lon=pos.coords.longitude;
      saveStationOverrides();
      if(updateActiveRoute && state.route && state.route.length){
        state.route.forEach(st=>{
          if(st.name===name){
            st.lat=pos.coords.latitude;
            st.lon=pos.coords.longitude;
          }
        });
        renderRouteCards();
      }
      renderCalibrationTable();
      showCalibrationMessage(`Uppdaterade ${name} med aktuell position.`, false);
    };
    if(state.lastPosition){
      applyPosition(state.lastPosition);
    }else if(navigator.geolocation){
      navigator.geolocation.getCurrentPosition(pos=>{
        state.lastPosition=pos;
        applyPosition(pos);
      }, err=>{
        showCalibrationMessage(err&&err.message?err.message:'Kunde inte l√§sa GPS.', true);
      }, {enableHighAccuracy:true, timeout:20000});
    }else{
      showCalibrationMessage('GPS saknas.', true);
    }
  }

  function showCalibrationMessage(text, isError){
    els.calibrationMsg.textContent=text;
    els.calibrationMsg.style.display='inline-block';
    els.calibrationMsg.style.background=isError?'#fee2e2':'#dcfce7';
    els.calibrationMsg.style.borderColor=isError?'#fecaca':'#86efac';
    setTimeout(()=>{ els.calibrationMsg.style.display='none'; },4000);
  }

  function loadStationOverrides(){
    try{
      const raw=localStorage.getItem(STORAGE_KEY_STATIONS);
      if(!raw) return {};
      const parsed=JSON.parse(raw);
      return parsed&&typeof parsed==='object'?parsed:{};
    }catch(e){
      return {};
    }
  }

  function saveStationOverrides(){
    try{
      localStorage.setItem(STORAGE_KEY_STATIONS, JSON.stringify(stationOverrides));
    }catch(e){}
  }

  function composeStationCatalog(){
    return baseStations.map(base=>{
      const override=stationOverrides[base.name]||{};
      const hasCustomRadius=override.radius!=null;
      const derivedRadius=hasCustomRadius?override.radius:(base.radius!=null?base.radius:DEFAULT_RADIUS);
      return {
        name:base.name,
        lat:override.lat!=null?override.lat:base.lat,
        lon:override.lon!=null?override.lon:base.lon,
        radius:isFinite(derivedRadius)?derivedRadius:DEFAULT_RADIUS,
        customRadius:hasCustomRadius
      };
    });
  }

  function showSetupError(text){
    els.setupError.textContent=text;
    els.setupError.style.display='inline-block';
  }

  function hideSetupError(){
    els.setupError.style.display='none';
  }

  function showJourneyMessage(text, isError){
    els.journeyMsg.textContent=text;
    els.journeyMsg.style.display='inline-block';
    els.journeyMsg.style.background=isError?'#fee2e2':'var(--soft)';
    els.journeyMsg.style.borderColor=isError?'#fecaca':'var(--softb)';
  }

  function resetForNewRun(){
    speedHistory.length=0; // rensa hastighetshistorik mellan k√∂rningar
    state.awaitingDepartureIndex=null;
    state.lastSpeed=null;
    state.lastSpeedTime=null;
    state.route=[];
    state.running=false;
    state.nextIndex=null;
    state.lastReachedIndex=0;
    els.report.style.display='none';
    els.journey.style.display='none';
    els.setup.style.display='block';
    els.cards.innerHTML='';
    updateNextStopUI();
  }

  function escapeHtml(str){
    return str.replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c]));
  }

  function haversine(lat1, lon1, lat2, lon2){
    const R=6371000;
    const toRad=deg=>deg*Math.PI/180;
    const dLat=toRad(lat2-lat1);
    const dLon=toRad(lon2-lon1);
    const a=Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
    const c=2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R*c;
  }

  const stationSignatures = {
    'Herrljunga': 'Hrc',
    'Vedum': 'Ved',
    'Vara': 'Vaa',
    'H√•kantorp': 'H√•p',
    'Stora Levene': 'Stlv',
    'J√§rp√•s': 'Jps',
    'Lovene': 'Lve',
    'Framn√§s City': 'Fc',
    'Lidk√∂ping': 'Lkp',
    'Filsb√§ck': 'Fi√§',
    'K√§llby': 'Kll',
    'Blomberg': 'Bmb',
    'Trolmen': 'Trm',
    'R√•b√§ck': 'Rbk',
    'H√§llekis': 'Hlk',
    'Forshem': 'Fhm',
    '√ñster√§ng': '√ñ√§g',
    '√Ñskek√§rr': '√Ñsr',
    'Lugn√•s': 'Ln√•',
    'Mariestad': 'Mst',
    'Hassler√∂r': 'Hsr',
    'Lyrestad': 'Lyd',
    'Torved': 'Tvd',
    'Hova': 'Hova',
    'G√•rdsj√∂': 'Gd√∂',
    'Lax√•': 'L√•',
    'Hallsberg personbang√•rd': 'Hpbg',
    'Kumla': 'Kla',
    '√ñrebro S√∂dra': '√ñb',
    '√ñrebro Central': '√ñr'
  };

  async function fetchTimetable(otn, date){
    if(!otn) return { success: false, error: 'Inget t√•gnummer angivet' };
    try{
      const targetDate = date ? new Date(date) : new Date();
      const targetDateStr = targetDate.toISOString().split('T')[0];

      const xmlRequest = `<REQUEST>
        <LOGIN authenticationkey="${TRAFIKVERKET_API_KEY}" />
        <QUERY objecttype="TrainAnnouncement" schemaversion="1.9" limit="500">
          <FILTER>
            <EQ name="OperationalTrainNumber" value="${otn}" />
          </FILTER>
          <INCLUDE>LocationSignature</INCLUDE>
          <INCLUDE>AdvertisedTimeAtLocation</INCLUDE>
          <INCLUDE>ActivityType</INCLUDE>
          <INCLUDE>OperationalTrainNumber</INCLUDE>
          <INCLUDE>DepartureDateOTN</INCLUDE>
          <INCLUDE>Advertised</INCLUDE>
        </QUERY>
      </REQUEST>`;

      const response = await fetch(TRAFIKVERKET_API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'text/xml' },
        body: xmlRequest
      });

      if(!response.ok) {
        return { success: false, error: `API-fel: HTTP ${response.status}` };
      }

      const data = await response.json();
      const announcements = data?.RESPONSE?.RESULT?.[0]?.TrainAnnouncement || [];

      if(!announcements.length) {
        return { success: false, error: `T√•g ${otn} hittades inte i tidtabellen` };
      }

      const filtered = announcements.filter(ann => {
        if(!ann.AdvertisedTimeAtLocation) return false;
        const annDate = new Date(ann.AdvertisedTimeAtLocation).toISOString().split('T')[0];
        return annDate === targetDateStr;
      });

      if(!filtered.length) {
        const availableDates = [...new Set(announcements
          .filter(a => a.AdvertisedTimeAtLocation)
          .map(a => new Date(a.AdvertisedTimeAtLocation).toISOString().split('T')[0])
        )].sort();

        return {
          success: false,
          error: `T√•g ${otn} g√•r inte ${targetDateStr}. G√•r: ${availableDates.join(', ')}`
        };
      }

      const timetable = {};
      const stationStops = new Set();

      filtered.forEach(ann => {
        const sig = ann.LocationSignature;
        const time = ann.AdvertisedTimeAtLocation;
        const activity = ann.ActivityType;
        const advertised = ann.Advertised;

        if(!sig || !time) return;

        if(!timetable[sig]) timetable[sig] = { hasArrival: false, hasDeparture: false };

        if(activity === 'Ankomst') {
          timetable[sig].arrival = new Date(time);
          timetable[sig].hasArrival = true;
        } else if(activity === 'Avgang') {
          timetable[sig].departure = new Date(time);
          timetable[sig].hasDeparture = true;
        }
      });

      Object.keys(timetable).forEach(sig => {
        const info = timetable[sig];
        if(info.hasArrival || info.hasDeparture) {
          stationStops.add(sig);
        }
      });

      return {
        success: true,
        timetable,
        stationStops: Array.from(stationStops),
        stationCount: Object.keys(timetable).length
      };
    }catch(err){
      console.error('Kunde inte h√§mta tidtabell:', err);
      let errorMsg = 'Ok√§nt fel vid API-anrop';
      if(!navigator.onLine){
        errorMsg = 'Ingen internetanslutning ‚Äì tidtabell kunde inte h√§mtas';
      }else if(err.name === 'TypeError' && err.message.includes('fetch')){
        errorMsg = 'N√§tverksfel ‚Äì kontrollera anslutningen';
      }else if(err.message){
        errorMsg = err.message;
      }
      return { success: false, error: errorMsg };
    }
  }

  function applyTimetableToRoute(timetable){
    if(!timetable || !state.route) return;

    state.route.forEach((station, idx) => {
      const sig = stationSignatures[station.name];
      if(!sig || !timetable[sig]) return;

      const isFirst = idx === 0;
      const isLast = idx === state.route.length - 1;

      if(!isFirst && timetable[sig].arrival) {
        station.scheduledArrival = timetable[sig].arrival;
      }

      if(!isLast && timetable[sig].departure) {
        station.scheduledDeparture = timetable[sig].departure;
      }
    });
  }

  function filterRouteByTimetable(stationStops){
    if(!stationStops || !state.route) return;

    const stopsSet = new Set(stationStops);
    const newRoute = [];

    state.route.forEach((station, idx) => {
      const sig = stationSignatures[station.name];
      const isFirst = idx === 0;
      const isLast = idx === state.route.length - 1;

      if(isFirst || isLast || stopsSet.has(sig)) {
        station.shouldStop = true;
        newRoute.push(station);
      } else {
        station.shouldStop = false;
      }
    });

    if(newRoute.length > 0) {
      newRoute.forEach((station, idx) => {
        station.order = idx + 1;
      });

      state.route = newRoute;
      state.lastReachedIndex = 0;
      state.nextIndex = newRoute.length > 1 ? 1 : null;
    }
  }

  function normalizeLogEntry(entry){
    if(!entry || typeof entry!=='object') return null;
    const stopsArray=Array.isArray(entry.stops)?entry.stops:[];
    const firstStop=stopsArray[0]||{};
    const lastStop=stopsArray[stopsArray.length-1]||{};
    const endpoints=parseRouteEndpoints(entry.route);
    const startStation = entry.startStation || endpoints.start || firstStop.name || '';
    const endStation = entry.endStation || endpoints.end || lastStop.name || '';
    const startedAt = entry.startedAt || entry.date || firstStop.actualDeparture || firstStop.actualArrival || null;
    const finishedAt = entry.finishedAt || lastStop.actualArrival || lastStop.actualDeparture || null;
    const normalizedStops = stopsArray.map((stop,idx)=>({
      name: stop.name || stop.station || `Uppeh√•ll ${idx+1}`,
      actualArrival: stop.actualArrival || stop.arrival || stop.arr || null,
      actualDeparture: stop.actualDeparture || stop.departure || stop.dep || null,
      scheduledArrival: stop.scheduledArrival || null,
      scheduledDeparture: stop.scheduledDeparture || null,
      arrivalSource: stop.arrivalSource || '',
      departSource: stop.departSource || '',
      shouldStop: stop.shouldStop!=null ? !!stop.shouldStop : !stop.skipNoStop,
      excludeInboundRun: !!(stop.excludeInboundRun || stop.exclude)
    }));
    const rawId = entry.id || entry.measurementId || entry.measurementID || `${entry.trainNumber||''}|${startStation||''}|${startedAt||''}`;
    return {
      id: String(rawId || Date.now().toString(36)),
      trainNumber: entry.trainNumber || '',
      startStation: startStation || '',
      endStation: endStation || '',
      startedAt: startedAt || null,
      finishedAt: finishedAt || null,
      aborted: !!entry.aborted,
      notes: entry.notes || entry.note || '',
      stops: normalizedStops
    };
  }

  function dedupeLogs(logs){
    const seen=new Set();
    const out=[];
    for(const entry of logs||[]){
      if(!entry) continue;
      const key=entry.id || entry.measurementId || `${entry.trainNumber||''}|${entry.startStation||''}|${entry.startedAt||''}`;
      if(!seen.has(key)){
        seen.add(key);
        out.push(entry);
      }
    }
    return out;
  }

  function parseRouteEndpoints(route){
    if(typeof route!=='string') return {start:'', end:''};
    const parts=route.split(/[-‚Üí]/).map(s=>s.trim()).filter(Boolean);
    if(!parts.length) return {start:'', end:''};
    return { start: parts[0], end: parts[parts.length-1] };
  }

  async function requestWakeLock(){
    if(!('wakeLock' in navigator)){
      showHeaderStatus('Sk√§rml√•s st√∂ds inte i denna webbl√§sare.', true);
      return;
    }
    try{
      wakeLockSentinel=await navigator.wakeLock.request('screen');
      keepScreenAwake=true;
      wakeLockSentinel.addEventListener('release', ()=>{
        wakeLockSentinel=null;
        updateWakeButton();
        if(keepScreenAwake && document.visibilityState==='visible'){
          requestWakeLock().catch(()=>{});
        }
      });
      updateWakeButton();
      showHeaderStatus('Sk√§rmen h√•lls vaken.', false);
    }catch(err){
      keepScreenAwake=false;
      wakeLockSentinel=null;
      updateWakeButton();
      showHeaderStatus('Kunde inte l√•sa sk√§rmen vaken.', true);
    }
  }

  function releaseWakeLock(){
    keepScreenAwake=false;
    if(wakeLockSentinel){
      wakeLockSentinel.release();
      wakeLockSentinel=null;
    }
    updateWakeButton();
    showHeaderStatus('Sk√§rmen f√•r slockna.', false);
  }

  function toggleWakeLock(){
    if(keepScreenAwake){
      releaseWakeLock();
    }else{
      requestWakeLock();
    }
  }

  function updateWakeButton(){
    if(!els.wakeBtn) return;
    els.wakeBtn.textContent=keepScreenAwake?'Till√•t sk√§rmen slockna':'H√•ll sk√§rmen vaken';
    els.wakeBtn.setAttribute('aria-pressed', keepScreenAwake?'true':'false');
    els.wakeBtn.classList.toggle('primary', keepScreenAwake);
  }

  function handleVisibilityChange(){
    if(document.visibilityState==='visible' && keepScreenAwake && !wakeLockSentinel){
      requestWakeLock();
    }
  }

  function setupPWA(){
    if(window.matchMedia && window.matchMedia('(display-mode: standalone)').matches){
      hideInstallButton();
    }
    if('serviceWorker' in navigator){
      window.addEventListener('load', ()=>{
        navigator.serviceWorker.register(`./sw.js?v=${APP_VERSION}`).then(reg=>{
          monitorServiceWorker(reg);
        }).catch(err=>{
          console.warn('Service worker misslyckades', err);
        });
      });
      navigator.serviceWorker.addEventListener('controllerchange', ()=>{
        if(updateTriggered){
          window.location.reload();
        }
      });
    }
    window.addEventListener('beforeinstallprompt', event=>{
      event.preventDefault();
      deferredInstallPrompt=event;
      if(els.installBtn){
        els.installBtn.style.display='inline-block';
      }
    });
    window.addEventListener('appinstalled', ()=>{
      showHeaderStatus('Appen installerades!', false);
      hideInstallButton();
    });
    if(els.installBtn){
      els.installBtn.addEventListener('click', async ()=>{
        if(!deferredInstallPrompt) return;
        els.installBtn.disabled=true;
        try{
          deferredInstallPrompt.prompt();
          const choice=await deferredInstallPrompt.userChoice;
          if(choice && choice.outcome==='accepted'){
            showHeaderStatus('Installationen startar‚Ä¶', false);
            hideInstallButton();
          }else{
            showHeaderStatus('Installationen avbr√∂ts.', true);
          }
        }catch(err){
          showHeaderStatus('Kunde inte starta installationen.', true);
        }finally{
          deferredInstallPrompt=null;
          els.installBtn.disabled=false;
        }
      });
    }
  }

  function monitorServiceWorker(reg){
    function listenForInstall(worker){
      if(!worker) return;
      worker.addEventListener('statechange', ()=>{
        if(worker.state==='installed'){
          if(navigator.serviceWorker.controller){
            pendingServiceWorker=worker;
            showUpdatePrompt();
          }
        }
      });
    }
    if(reg.waiting && navigator.serviceWorker.controller){
      pendingServiceWorker=reg.waiting;
      showUpdatePrompt();
    }
    if(reg.installing){
      listenForInstall(reg.installing);
    }
    reg.addEventListener('updatefound', ()=>{
      listenForInstall(reg.installing);
    });
  }

  function hideInstallButton(){
    if(els.installBtn){
      els.installBtn.style.display='none';
    }
  }

  function showUpdatePrompt(){
    if(!els.updateBtn) return;
    els.updateBtn.style.display='inline-block';
    els.updateBtn.disabled=false;
    showHeaderStatus('Ny version finns ‚Äì uppdatera appen.', false);
  }

  function showHeaderStatus(text, isError){
    if(!els.headerStatus) return;
    els.headerStatus.textContent=text;
    els.headerStatus.style.display='inline-block';
    els.headerStatus.style.background=isError?'#fee2e2':'#dcfce7';
    els.headerStatus.style.borderColor=isError?'#fecaca':'#86efac';
    clearTimeout(showHeaderStatus._timer);
    showHeaderStatus._timer=setTimeout(()=>{
      els.headerStatus.style.display='none';
    },4000);
  }

  init();
})();
</script>
</body>
</html>
