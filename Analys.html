<!DOCTYPE html>
<html lang="sv">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>RailTimer - Tidsanalys</title>
<style>
  :root{
    --bg:#1a1d23;
    --bg-solid:#0d0f12;
    --ink:#e8eaed;
    --ink-dim:#9aa0a6;
    --mut:#6b7280;
    --pri:#22c55e;
    --pri-dark:#16a34a;
    --pri-glow:rgba(34,197,94,0.15);
    --sec:#f59e0b;
    --b:#2d3139;
    --b-light:#3d4149;
    --card-bg:#1e2128;
    --err:#ef4444;
    --warn:#f59e0b;
    --blue:#3b82f6;
  }
  *{box-sizing:border-box}
  body{
    font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
    margin:0;
    padding:0;
    line-height:1.5;
    background:var(--bg-solid);
    color:var(--ink);
    min-height:100vh;
  }
  header{
    background:var(--bg);
    padding:.75rem 1rem;
    border-bottom:1px solid var(--b);
    position:sticky;
    top:0;
    z-index:10;
  }
  h1{margin:0 0 .5rem;font-size:1.1rem;font-weight:600}
  h1::before{content:'üìä '}
  .mode-tabs{display:flex;gap:.25rem}
  .mode-tab{
    padding:.35rem .75rem;
    border:1px solid var(--b);
    background:transparent;
    color:var(--ink-dim);
    font-size:.8rem;
    cursor:pointer;
    border-radius:6px;
  }
  .mode-tab.active{background:var(--pri);color:#000;border-color:var(--pri);font-weight:600}
  .mode-tab:hover:not(.active){background:var(--b)}
  h2{margin:1.25rem 0 .75rem;font-size:1rem;font-weight:600;color:var(--ink)}
  h3{margin:1rem 0 .5rem;font-size:.9rem;font-weight:600;color:var(--ink-dim)}
  main{padding:1rem;max-width:1200px;margin:0 auto}

  .filters{
    display:flex;
    gap:.5rem;
    flex-wrap:wrap;
    margin-bottom:1rem;
    align-items:flex-end;
  }
  .filter-group{
    display:flex;
    flex-direction:column;
    gap:.25rem;
  }
  .filter-group label{
    font-size:.7rem;
    color:var(--mut);
    text-transform:uppercase;
    letter-spacing:.03em;
  }
  select,input[type="date"],input[type="file"],input[type="text"]{
    padding:.4rem .6rem;
    border:1px solid var(--b);
    border-radius:6px;
    background:var(--card-bg);
    color:var(--ink);
    font-size:.85rem;
    min-width:120px;
  }
  select:focus,input:focus{
    outline:none;
    border-color:var(--pri);
  }
  button{
    padding:.4rem .8rem;
    border:1px solid var(--b);
    border-radius:6px;
    background:var(--card-bg);
    color:var(--ink);
    font-size:.85rem;
    cursor:pointer;
    transition:all .15s;
  }
  button:hover:not(:disabled){background:var(--b)}
  button:disabled{opacity:.4;cursor:not-allowed}
  button.primary{background:var(--pri);color:#000;border-color:var(--pri);font-weight:600}
  button.primary:hover:not(:disabled){background:var(--pri-dark)}
  button.ghost{background:transparent;color:var(--pri);border-color:var(--b)}

  .card{
    background:var(--card-bg);
    border:1px solid var(--b);
    border-radius:10px;
    padding:1rem;
    margin-bottom:1rem;
  }
  .stats-row{
    display:grid;
    grid-template-columns:repeat(auto-fit, minmax(120px, 1fr));
    gap:.75rem;
    margin-bottom:1rem;
  }
  .stat-box{
    background:var(--bg);
    border:1px solid var(--b);
    border-radius:8px;
    padding:.6rem .75rem;
    text-align:center;
  }
  .stat-box .value{font-size:1.5rem;font-weight:700;color:var(--pri)}
  .stat-box .label{font-size:.7rem;color:var(--mut);text-transform:uppercase}

  .chart-container{
    background:var(--card-bg);
    border:1px solid var(--b);
    border-radius:10px;
    padding:1rem;
    margin-bottom:1rem;
    overflow-x:auto;
  }
  canvas{display:block;max-width:100%}

  .table-wrap{overflow-x:auto;border-radius:8px;border:1px solid var(--b)}
  table{border-collapse:collapse;width:100%;background:var(--card-bg);font-size:.8rem}
  th,td{border:1px solid var(--b);padding:.5rem .6rem;text-align:left}
  th{background:var(--bg);color:var(--ink-dim);font-weight:600;font-size:.7rem;text-transform:uppercase;letter-spacing:.03em}
  td{color:var(--ink)}
  tr:hover td{background:var(--bg)}

  .badge{
    display:inline-block;
    padding:.15rem .4rem;
    border-radius:4px;
    font-size:.7rem;
    font-weight:600;
  }
  .badge.good{background:rgba(34,197,94,0.15);color:var(--pri)}
  .badge.warn{background:rgba(245,158,11,0.15);color:var(--warn)}
  .badge.bad{background:rgba(239,68,68,0.15);color:var(--err)}

  .meta{font-size:.8rem;color:var(--mut);margin-top:.5rem}
  .empty{text-align:center;padding:2rem;color:var(--mut)}

  .tabs{display:flex;gap:.25rem;margin-bottom:1rem;border-bottom:1px solid var(--b);padding-bottom:.5rem}
  .tab{
    padding:.4rem .8rem;
    border:none;
    background:transparent;
    color:var(--ink-dim);
    cursor:pointer;
    border-radius:6px 6px 0 0;
    font-size:.85rem;
  }
  .tab.active{background:var(--pri-glow);color:var(--pri);font-weight:600}
  .tab:hover:not(.active){background:var(--b)}

  .tab-content{display:none}
  .tab-content.active{display:block}

  @media (max-width:640px){
    .filters{flex-direction:column}
    .filter-group{width:100%}
    select,input{width:100%}
    .stats-row{grid-template-columns:repeat(2,1fr)}
  }
</style>
</head>
<body>
<header>
  <h1>RailTimer Tidsanalys</h1>
  <div class="mode-tabs">
    <button class="mode-tab active" data-mode="running">G√•ngtider</button>
    <button class="mode-tab" data-mode="dwell">Uppeh√•llstider</button>
  </div>
</header>

<main>
  <div class="card">
    <h3>Datak√§lla</h3>
    <div class="filters">
      <button id="btnLoadLocal" class="primary">Ladda fr√•n RailTimer</button>
      <span style="color:var(--mut);font-size:.85rem">eller</span>
      <div class="filter-group">
        <label>Importera JSON-fil(er)</label>
        <input type="file" id="fileInput" accept=".json" multiple>
      </div>
    </div>
    <div id="loadStatus" class="meta"></div>
  </div>

  <div class="card">
    <h3>Filter</h3>
    <div class="filters">
      <div class="filter-group">
        <label>Fordonstyp</label>
        <select id="filterVehicle"><option value="">Alla</option></select>
      </div>
      <div class="filter-group">
        <label>T√•gnummer</label>
        <select id="filterTrain"><option value="">Alla</option></select>
      </div>
      <div class="filter-group">
        <label>Station 1</label>
        <input type="text" id="filterFrom" list="stationList1" placeholder="S√∂k station...">
        <datalist id="stationList1"></datalist>
      </div>
      <div class="filter-group">
        <label>Station 2</label>
        <input type="text" id="filterTo" list="stationList2" placeholder="S√∂k station...">
        <datalist id="stationList2"></datalist>
      </div>
      <div class="filter-group">
        <label>Fr√•n datum</label>
        <input type="date" id="filterDateFrom">
      </div>
      <div class="filter-group">
        <label>Till datum</label>
        <input type="date" id="filterDateTo">
      </div>
      <div class="filter-group">
        <label>&nbsp;</label>
        <button id="btnClearFilters" class="ghost">Rensa filter</button>
      </div>
    </div>
    <div class="filters">
      <label style="display:flex;align-items:center;gap:.4rem;font-size:.85rem;color:var(--ink-dim)">
        <input type="checkbox" id="chkMergeDir" checked> Sl√• ihop riktningar (A‚ÜîB)
      </label>
    </div>
  </div>

  <div id="modeDescription" class="meta" style="margin-bottom:1rem;padding:.5rem .75rem;background:var(--card-bg);border-radius:6px;border:1px solid var(--b)">
    <strong>G√•ngtid</strong> = Tid fr√•n avg√•ng vid en station till ankomst vid n√§sta station (exkl. uppeh√•ll).
  </div>

  <div class="stats-row">
    <div class="stat-box">
      <div class="value" id="statTrips">0</div>
      <div class="label">K√∂rningar</div>
    </div>
    <div class="stat-box">
      <div class="value" id="statSegments">0</div>
      <div class="label">Str√§ckor</div>
    </div>
    <div class="stat-box">
      <div class="value" id="statObservations">0</div>
      <div class="label">Observationer</div>
    </div>
    <div class="stat-box">
      <div class="value" id="statAvgTime">-</div>
      <div class="label">Snitt g√•ngtid</div>
    </div>
  </div>

  <div class="tabs">
    <button class="tab active" data-tab="chart">Diagram</button>
    <button class="tab" data-tab="table">Tabell</button>
    <button class="tab" data-tab="outliers">Avvikare</button>
    <button class="tab" data-tab="details">Detaljer</button>
  </div>

  <div id="tabChart" class="tab-content active">
    <div class="chart-container">
      <canvas id="chart" width="1200" height="650"></canvas>
    </div>
  </div>

  <div id="tabTable" class="tab-content">
    <div class="table-wrap">
      <table id="summaryTable">
        <thead>
          <tr>
            <th title="Str√§cka mellan tv√• stationer, eller stationsnamn f√∂r uppeh√•llstider">Str√§cka</th>
            <th title="Antal observationer/m√§tningar">Antal</th>
            <th title="Medelv√§rde: summan av alla tider delat med antalet">Snitt</th>
            <th title="Standardavvikelse: m√•tt p√• spridningen. L√•gt v√§rde = tiderna √§r lika, h√∂gt v√§rde = stor variation">Std</th>
            <th title="Median: mittv√§rdet n√§r alla tider sorterats. H√§lften √§r kortare, h√§lften l√§ngre. P√•verkas inte av extremv√§rden.">Median</th>
            <th title="90:e percentilen: 90% av tiderna √§r kortare √§n detta v√§rde. Visar 'normalt l√•ngsam' tid.">P90</th>
            <th title="Kortaste uppm√§tta tiden">Min</th>
            <th title="L√§ngsta uppm√§tta tiden">Max</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <div class="card" style="margin-top:1rem;padding:.75rem 1rem;font-size:.8rem;color:var(--ink-dim)">
      <strong style="color:var(--ink)">F√∂rklaring av kolumner:</strong><br>
      <strong>Snitt</strong> = Medelv√§rde (summan / antal) ¬∑
      <strong>Std</strong> = Standardavvikelse (spridning, l√•gt=j√§mnt, h√∂gt=varierande) ¬∑
      <strong>Median</strong> = Mittv√§rdet (50% √§r snabbare, 50% l√•ngsammare) ¬∑
      <strong>P90</strong> = 90:e percentilen (90% av tiderna √§r kortare)<br>
      <em>Alla tider visas i minuter.</em>
    </div>
  </div>

  <div id="tabOutliers" class="tab-content">
    <p class="meta">T√•gnummer med g√•ngtider som avviker mer √§n 2 standardavvikelser fr√•n snittet.</p>
    <div class="table-wrap">
      <table id="outliersTable">
        <thead>
          <tr>
            <th>Str√§cka</th>
            <th>T√•g</th>
            <th>Fordon</th>
            <th>Antal</th>
            <th>T√•g-snitt</th>
            <th>Glob. snitt</th>
            <th>z-score</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div id="tabDetails" class="tab-content">
    <p class="meta">Alla enskilda g√•ngtidsobservationer med aktuellt filter.</p>
    <div class="table-wrap">
      <table id="detailsTable">
        <thead>
          <tr>
            <th>Datum</th>
            <th>T√•g</th>
            <th>Fordon</th>
            <th>Str√§cka</th>
            <th>Tid (min)</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
</main>

<script>
(function(){
  'use strict';

  const STORAGE_KEY = 'kmon_gps_logs_v1';
  let allLogs = [];
  let segments = [];
  let currentMode = 'running'; // 'running' or 'dwell'
  let validStations = new Set();

  // Elements
  const els = {
    btnLoadLocal: document.getElementById('btnLoadLocal'),
    fileInput: document.getElementById('fileInput'),
    loadStatus: document.getElementById('loadStatus'),
    filterVehicle: document.getElementById('filterVehicle'),
    filterTrain: document.getElementById('filterTrain'),
    filterFrom: document.getElementById('filterFrom'),
    filterTo: document.getElementById('filterTo'),
    filterDateFrom: document.getElementById('filterDateFrom'),
    filterDateTo: document.getElementById('filterDateTo'),
    btnClearFilters: document.getElementById('btnClearFilters'),
    chkMergeDir: document.getElementById('chkMergeDir'),
    statTrips: document.getElementById('statTrips'),
    statSegments: document.getElementById('statSegments'),
    statObservations: document.getElementById('statObservations'),
    statAvgTime: document.getElementById('statAvgTime'),
    summaryTable: document.querySelector('#summaryTable tbody'),
    outliersTable: document.querySelector('#outliersTable tbody'),
    detailsTable: document.querySelector('#detailsTable tbody'),
    chart: document.getElementById('chart')
  };

  const ctx = els.chart.getContext('2d');

  // Event listeners
  els.btnLoadLocal.addEventListener('click', loadFromLocalStorage);
  els.fileInput.addEventListener('change', loadFromFile);
  els.btnClearFilters.addEventListener('click', clearFilters);
  els.chkMergeDir.addEventListener('change', runAnalysis);
  els.filterVehicle.addEventListener('change', runAnalysis);
  els.filterTrain.addEventListener('change', runAnalysis);
  els.filterFrom.addEventListener('input', runAnalysis);
  els.filterTo.addEventListener('input', runAnalysis);
  els.filterDateFrom.addEventListener('change', runAnalysis);
  els.filterDateTo.addEventListener('change', runAnalysis);

  // Mode tabs (G√•ngtider / Uppeh√•llstider)
  document.querySelectorAll('.mode-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      currentMode = tab.dataset.mode;
      updateModeLabels();
      runAnalysis();
    });
  });

  function updateModeLabels(){
    const isRunning = currentMode === 'running';
    document.querySelector('#summaryTable thead th:first-child').textContent = isRunning ? 'Str√§cka' : 'Station';
    document.querySelector('#detailsTable thead th:nth-child(4)').textContent = isRunning ? 'Str√§cka' : 'Station';
    // Show/hide merge direction option (only for running times)
    els.chkMergeDir.parentElement.style.display = isRunning ? 'flex' : 'none';
    // Update mode description
    document.getElementById('modeDescription').innerHTML = isRunning
      ? '<strong>G√•ngtid</strong> = Tid fr√•n avg√•ng vid en station till ankomst vid n√§sta station (exkl. uppeh√•ll).'
      : '<strong>Uppeh√•llstid</strong> = Tid fr√•n ankomst till avg√•ng vid samma station (hur l√§nge t√•get stod stilla).';
  }

  // Data tabs
  document.querySelectorAll('.tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      tab.classList.add('active');
      document.getElementById('tab' + capitalize(tab.dataset.tab)).classList.add('active');
    });
  });

  function capitalize(s){ return s.charAt(0).toUpperCase() + s.slice(1); }

  function loadFromLocalStorage(){
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw){
        els.loadStatus.textContent = 'Inga sparade k√∂rningar hittades i RailTimer.';
        return;
      }
      allLogs = JSON.parse(raw);
      if(!Array.isArray(allLogs)) allLogs = [];
      els.loadStatus.textContent = `Laddade ${allLogs.length} k√∂rningar fr√•n RailTimer.`;
      setupFilters();
      runAnalysis();
    } catch(e){
      els.loadStatus.textContent = 'Fel vid laddning: ' + e.message;
    }
  }

  async function loadFromFile(e){
    const files = e.target.files;
    if(!files || files.length === 0) return;

    try {
      let rawLogs = [];
      let totalFiles = 0;

      for(const file of files){
        const text = await file.text();
        let parsed = JSON.parse(text);
        if(!Array.isArray(parsed)) parsed = [parsed];
        rawLogs = rawLogs.concat(parsed);
        totalFiles++;
      }

      // Deduplicera baserat p√• id eller startedAt+trainNumber
      const seen = new Set();
      allLogs = [];
      let duplicates = 0;

      for(const log of rawLogs){
        const key = log.id || `${log.startedAt}|${log.trainNumber}`;
        if(seen.has(key)){
          duplicates++;
          continue;
        }
        seen.add(key);
        allLogs.push(log);
      }

      const fileWord = totalFiles === 1 ? 'fil' : 'filer';
      let statusText = `Laddade ${allLogs.length} k√∂rningar fr√•n ${totalFiles} ${fileWord}.`;
      if(duplicates > 0){
        statusText += ` (${duplicates} dubletter filtrerades bort)`;
      }
      els.loadStatus.textContent = statusText;
      setupFilters();
      runAnalysis();
    } catch(err){
      els.loadStatus.textContent = 'Ogiltig JSON-fil: ' + err.message;
    }
  }

  function setupFilters(){
    const vehicles = new Set();
    const trains = new Set();
    const stations = new Set();

    allLogs.forEach(log => {
      if(log.vehicleType) vehicles.add(log.vehicleType);
      if(log.trainNumber) trains.add(log.trainNumber);
      (log.stops || []).forEach(s => {
        if(s.name) stations.add(s.name);
      });
    });

    fillSelect(els.filterVehicle, Array.from(vehicles).sort(), 'Alla fordon');
    fillSelect(els.filterTrain, Array.from(trains).sort(), 'Alla t√•g');

    // Fill datalists for station search
    validStations = stations;
    const sortedStations = Array.from(stations).sort();
    fillDatalist('stationList1', sortedStations);
    fillDatalist('stationList2', sortedStations);
  }

  function fillDatalist(id, options){
    const dl = document.getElementById(id);
    dl.innerHTML = options.map(o => `<option value="${escapeHtml(o)}">`).join('');
  }

  function fillSelect(el, options, defaultLabel){
    el.innerHTML = `<option value="">${defaultLabel}</option>` +
      options.map(o => `<option value="${escapeHtml(o)}">${escapeHtml(o)}</option>`).join('');
  }

  function escapeHtml(str){
    if(!str) return '';
    return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
  }

  function clearFilters(){
    els.filterVehicle.value = '';
    els.filterTrain.value = '';
    els.filterFrom.value = '';
    els.filterTo.value = '';
    els.filterDateFrom.value = '';
    els.filterDateTo.value = '';
    runAnalysis();
  }

  function runAnalysis(){
    if(!allLogs.length){
      showEmpty();
      return;
    }

    const mergeDir = els.chkMergeDir.checked;
    const filterVehicle = els.filterVehicle.value;
    const filterTrain = els.filterTrain.value;
    // Only use station filter if it's a valid station name
    const filterFrom = validStations.has(els.filterFrom.value) ? els.filterFrom.value : '';
    const filterTo = validStations.has(els.filterTo.value) ? els.filterTo.value : '';
    const filterDateFrom = els.filterDateFrom.value;
    const filterDateTo = els.filterDateTo.value;

    // Filter logs first
    let filteredLogs = allLogs.filter(log => {
      if(log.aborted) return false;
      if(filterVehicle && log.vehicleType !== filterVehicle) return false;
      if(filterTrain && log.trainNumber !== filterTrain) return false;
      if(filterDateFrom || filterDateTo){
        const logDate = log.startedAt ? new Date(log.startedAt).toISOString().slice(0,10) : null;
        if(!logDate) return false;
        if(filterDateFrom && logDate < filterDateFrom) return false;
        if(filterDateTo && logDate > filterDateTo) return false;
      }
      return true;
    });

    // Build segments based on mode
    if(currentMode === 'running'){
      // Special case: two stations selected - show segments between them + total
      if(filterFrom && filterTo && filterFrom !== filterTo){
        segments = buildSegmentsBetweenStations(filteredLogs, filterFrom, filterTo, mergeDir);
      } else {
        segments = buildRunningSegments(filteredLogs, mergeDir);

        // Filter by single station if specified
        if(filterFrom || filterTo){
          const station = filterFrom || filterTo;
          segments = segments.filter(seg => seg.from === station || seg.to === station);
        }
      }
    } else {
      segments = buildDwellSegments(filteredLogs);

      // Filter by station if specified (OR logic)
      if(filterFrom || filterTo){
        segments = segments.filter(seg => {
          if(filterFrom && filterTo){
            return seg.station === filterFrom || seg.station === filterTo;
          } else {
            const station = filterFrom || filterTo;
            return seg.station === station;
          }
        });
      }
    }

    updateStats(filteredLogs, segments);
    renderChart(segments, mergeDir);
    renderSummaryTable(segments);
    renderOutliersTable(segments);
    renderDetailsTable(segments);
  }

  function buildSegmentsBetweenStations(logs, station1, station2, mergeDir){
    const results = [];

    for(const log of logs){
      const stops = log.stops || [];
      if(stops.length < 2) continue;

      // Only include journeys where start/end stations match the selected stations
      const journeyStart = log.startStation || (stops[0] && stops[0].name);
      const journeyEnd = log.endStation || (stops[stops.length-1] && stops[stops.length-1].name);

      const matchesRoute =
        (journeyStart === station1 && journeyEnd === station2) ||
        (journeyStart === station2 && journeyEnd === station1);

      if(!matchesRoute) continue;

      // Find indices of both stations
      const idx1 = stops.findIndex(s => s.name === station1);
      const idx2 = stops.findIndex(s => s.name === station2);

      if(idx1 === -1 || idx2 === -1) continue; // Journey doesn't have both stations

      const startIdx = Math.min(idx1, idx2);
      const endIdx = Math.max(idx1, idx2);
      const startStop = stops[startIdx];
      const endStop = stops[endIdx];

      // Check we have departure from start and arrival at end
      if(!startStop.actualDeparture || !endStop.actualArrival) continue;

      const logDate = log.startedAt ? new Date(log.startedAt).toISOString().slice(0,10) : '?';
      const startTime = new Date(startStop.actualDeparture);
      const endTime = new Date(endStop.actualArrival);
      const totalMinutes = (endTime - startTime) / 60000;

      if(totalMinutes <= 0 || totalMinutes > 180) continue; // Sanity check

      // Add individual segments between CONSECUTIVE stations
      for(let i = startIdx; i < endIdx; i++){
        const fromStop = stops[i];
        const toStop = stops[i + 1];

        if(!fromStop.actualDeparture || !toStop.actualArrival) continue;
        if(toStop.excludeInboundRun) continue;

        const depTime = new Date(fromStop.actualDeparture);
        const arrTime = new Date(toStop.actualArrival);
        const minutes = (arrTime - depTime) / 60000;

        if(minutes > 0.1 && minutes < 180){
          let segmentKey = mergeDir
            ? [fromStop.name, toStop.name].sort().join(' ‚Üî ')
            : `${fromStop.name} ‚Üí ${toStop.name}`;

          results.push({
            segment: segmentKey,
            from: fromStop.name,
            to: toStop.name,
            minutes: minutes,
            trainNumber: log.trainNumber || '?',
            vehicleType: log.vehicleType || '?',
            date: logDate,
            logId: log.id,
            isTotal: false
          });
        }
      }

      // Add total segment
      const totalKey = mergeDir
        ? [station1, station2].sort().join(' ‚Üî ') + ' (total)'
        : `${stops[startIdx].name} ‚Üí ${stops[endIdx].name} (total)`;

      results.push({
        segment: totalKey,
        from: stops[startIdx].name,
        to: stops[endIdx].name,
        minutes: totalMinutes,
        trainNumber: log.trainNumber || '?',
        vehicleType: log.vehicleType || '?',
        date: logDate,
        logId: log.id,
        isTotal: true
      });
    }

    return results;
  }

  function buildRunningSegments(logs, mergeDir){
    const results = [];

    for(const log of logs){
      const stops = log.stops || [];
      if(stops.length < 2) continue;

      const logDate = log.startedAt ? new Date(log.startedAt).toISOString().slice(0,10) : '?';

      // Find segments between CONSECUTIVE stations
      for(let i = 0; i < stops.length - 1; i++){
        const fromStop = stops[i];
        const toStop = stops[i + 1];

        if(!fromStop.actualDeparture || !toStop.actualArrival) continue;
        if(toStop.excludeInboundRun) continue;

        const depTime = new Date(fromStop.actualDeparture);
        const arrTime = new Date(toStop.actualArrival);
        const minutes = (arrTime - depTime) / 60000;

        if(minutes > 0.1 && minutes < 180){ // Sanity check
          let segmentKey = mergeDir
            ? [fromStop.name, toStop.name].sort().join(' ‚Üî ')
            : `${fromStop.name} ‚Üí ${toStop.name}`;

          results.push({
            segment: segmentKey,
            from: fromStop.name,
            to: toStop.name,
            minutes: minutes,
            trainNumber: log.trainNumber || '?',
            vehicleType: log.vehicleType || '?',
            date: logDate,
            logId: log.id
          });
        }
      }
    }

    return results;
  }

  function buildDwellSegments(logs){
    const results = [];

    for(const log of logs){
      const stops = log.stops || [];
      const logDate = log.startedAt ? new Date(log.startedAt).toISOString().slice(0,10) : '?';

      for(const stop of stops){
        const hasArrival = !!stop.actualArrival;
        const hasDeparture = !!stop.actualDeparture;

        if(hasArrival && hasDeparture){
          const arrTime = new Date(stop.actualArrival);
          const depTime = new Date(stop.actualDeparture);
          const minutes = (depTime - arrTime) / 60000;

          // Only count as real dwell if > 3 seconds
          if(minutes > 0.05 && minutes < 60){ // Sanity: 3 sec to 60 min
            results.push({
              segment: stop.name,
              station: stop.name,
              from: stop.name,
              to: stop.name,
              minutes: minutes,
              trainNumber: log.trainNumber || '?',
              vehicleType: log.vehicleType || '?',
              date: logDate,
              logId: log.id
            });
          }
        }
      }
    }

    return results;
  }

  function updateStats(logs, segs){
    const uniqueSegments = new Set(segs.map(s => s.segment));
    const avgTime = segs.length > 0
      ? (segs.reduce((sum, s) => sum + s.minutes, 0) / segs.length).toFixed(1)
      : '-';

    els.statTrips.textContent = logs.length;
    els.statSegments.textContent = uniqueSegments.size;
    els.statObservations.textContent = segs.length;
    els.statAvgTime.textContent = avgTime;
  }

  function showEmpty(){
    els.statTrips.textContent = '0';
    els.statSegments.textContent = '0';
    els.statObservations.textContent = '0';
    els.statAvgTime.textContent = '-';
    els.summaryTable.innerHTML = '<tr><td colspan="8" class="empty">Ladda data f√∂r att se analys</td></tr>';
    els.outliersTable.innerHTML = '<tr><td colspan="7" class="empty">Ladda data f√∂r att se analys</td></tr>';
    els.detailsTable.innerHTML = '<tr><td colspan="5" class="empty">Ladda data f√∂r att se analys</td></tr>';
    drawEmptyChart();
  }

  function renderSummaryTable(segs){
    if(!segs.length){
      els.summaryTable.innerHTML = '<tr><td colspan="8" class="empty">Inga data med aktuellt filter</td></tr>';
      return;
    }

    // Group by segment
    const grouped = {};
    segs.forEach(s => {
      if(!grouped[s.segment]) grouped[s.segment] = { times: [], isTotal: s.isTotal || false };
      grouped[s.segment].times.push(s.minutes);
    });

    const summary = Object.entries(grouped).map(([seg, data]) => ({
      segment: seg,
      n: data.times.length,
      mean: mean(data.times),
      std: std(data.times),
      median: median(data.times),
      p90: quantile(data.times, 0.9),
      min: Math.min(...data.times),
      max: Math.max(...data.times),
      isTotal: data.isTotal
    })).sort((a, b) => {
      // Sort: totals last, then by mean descending
      if(a.isTotal !== b.isTotal) return a.isTotal ? 1 : -1;
      return b.mean - a.mean;
    });

    els.summaryTable.innerHTML = summary.map(s => `
      <tr style="${s.isTotal ? 'background:rgba(245,158,11,0.15);font-weight:600' : ''}">
        <td>${escapeHtml(s.segment)}</td>
        <td>${s.n}</td>
        <td>${s.mean.toFixed(2)}</td>
        <td>${s.std.toFixed(2)}</td>
        <td>${s.median.toFixed(2)}</td>
        <td>${s.p90.toFixed(2)}</td>
        <td>${s.min.toFixed(2)}</td>
        <td>${s.max.toFixed(2)}</td>
      </tr>
    `).join('');
  }

  function renderOutliersTable(segs){
    // Exclude total segments from outlier analysis
    const filteredSegs = segs.filter(s => !s.isTotal);

    if(!filteredSegs.length){
      els.outliersTable.innerHTML = '<tr><td colspan="7" class="empty">Inga data med aktuellt filter</td></tr>';
      return;
    }

    // Calculate global stats per segment
    const segmentStats = {};
    filteredSegs.forEach(s => {
      if(!segmentStats[s.segment]) segmentStats[s.segment] = [];
      segmentStats[s.segment].push(s.minutes);
    });

    const globalStats = {};
    Object.entries(segmentStats).forEach(([seg, times]) => {
      globalStats[seg] = { mean: mean(times), std: std(times) };
    });

    // Group by segment + train
    const byTrain = {};
    filteredSegs.forEach(s => {
      const key = `${s.segment}||${s.trainNumber}||${s.vehicleType}`;
      if(!byTrain[key]) byTrain[key] = { segment: s.segment, train: s.trainNumber, vehicle: s.vehicleType, times: [] };
      byTrain[key].times.push(s.minutes);
    });

    // Find outliers (z > 2, n >= 2)
    const outliers = [];
    Object.values(byTrain).forEach(group => {
      if(group.times.length < 2) return;
      const trainMean = mean(group.times);
      const global = globalStats[group.segment];
      if(!global || global.std === 0) return;
      const z = (trainMean - global.mean) / global.std;
      if(Math.abs(z) > 2){
        outliers.push({
          segment: group.segment,
          train: group.train,
          vehicle: group.vehicle,
          n: group.times.length,
          trainMean: trainMean,
          globalMean: global.mean,
          z: z
        });
      }
    });

    outliers.sort((a, b) => Math.abs(b.z) - Math.abs(a.z));

    if(!outliers.length){
      els.outliersTable.innerHTML = '<tr><td colspan="7" class="empty">Inga avvikande t√•gnummer hittades</td></tr>';
      return;
    }

    els.outliersTable.innerHTML = outliers.map(o => `
      <tr>
        <td>${escapeHtml(o.segment)}</td>
        <td>${escapeHtml(o.train)}</td>
        <td>${escapeHtml(o.vehicle)}</td>
        <td>${o.n}</td>
        <td>${o.trainMean.toFixed(2)}</td>
        <td>${o.globalMean.toFixed(2)}</td>
        <td><span class="badge ${o.z > 0 ? 'bad' : 'good'}">${o.z.toFixed(2)}</span></td>
      </tr>
    `).join('');
  }

  function renderDetailsTable(segs){
    if(!segs.length){
      els.detailsTable.innerHTML = '<tr><td colspan="5" class="empty">Inga data med aktuellt filter</td></tr>';
      return;
    }

    // Sort by date descending
    const sorted = [...segs].sort((a, b) => b.date.localeCompare(a.date));

    // Limit to 200 rows for performance
    const limited = sorted.slice(0, 200);

    els.detailsTable.innerHTML = limited.map(s => `
      <tr style="${s.isTotal ? 'background:rgba(245,158,11,0.15);font-weight:600' : ''}">
        <td>${escapeHtml(s.date)}</td>
        <td>${escapeHtml(s.trainNumber)}</td>
        <td>${escapeHtml(s.vehicleType)}</td>
        <td>${escapeHtml(s.segment)}</td>
        <td>${s.minutes.toFixed(2)}</td>
      </tr>
    `).join('');

    if(sorted.length > 200){
      els.detailsTable.innerHTML += `<tr><td colspan="5" class="meta">Visar 200 av ${sorted.length} rader</td></tr>`;
    }
  }

  function renderChart(segs, mergeDir){
    if(!segs.length){
      drawEmptyChart();
      return;
    }

    // Group by segment
    const grouped = {};
    segs.forEach(s => {
      if(!grouped[s.segment]) grouped[s.segment] = { times: [], isTotal: s.isTotal || false };
      grouped[s.segment].times.push(s.minutes);
    });

    const summary = Object.entries(grouped).map(([seg, data]) => ({
      segment: seg,
      n: data.times.length,
      mean: mean(data.times),
      isTotal: data.isTotal
    })).sort((a, b) => {
      // Sort: totals last, then by mean descending
      if(a.isTotal !== b.isTotal) return a.isTotal ? 1 : -1;
      return b.mean - a.mean;
    });

    drawBarChart(summary);
  }

  function drawEmptyChart(){
    const w = els.chart.width;
    const h = els.chart.height;
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = '#6b7280';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = '14px system-ui, sans-serif';
    ctx.fillText('Ladda data f√∂r att se diagram', w/2, h/2);
  }

  function drawBarChart(data){
    const w = els.chart.width;
    const h = els.chart.height;
    const padding = { left: 60, right: 30, top: 40, bottom: 220 };
    const chartW = w - padding.left - padding.right;
    const chartH = h - padding.top - padding.bottom;

    ctx.clearRect(0, 0, w, h);

    if(!data.length) return;

    const maxVal = Math.max(...data.map(d => d.mean));
    const yMax = niceMax(maxVal);

    // Draw grid
    ctx.strokeStyle = '#2d3139';
    ctx.lineWidth = 1;
    const gridLines = 5;
    for(let i = 0; i <= gridLines; i++){
      const y = padding.top + chartH - (chartH * i / gridLines);
      ctx.beginPath();
      ctx.moveTo(padding.left, y);
      ctx.lineTo(w - padding.right, y);
      ctx.stroke();

      // Y-axis labels
      ctx.fillStyle = '#9aa0a6';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      ctx.font = '13px system-ui, sans-serif';
      const val = (yMax * i / gridLines).toFixed(1);
      ctx.fillText(val, padding.left - 10, y);
    }

    // Draw bars
    const barGap = 6;
    const barWidth = Math.max(12, Math.min(50, (chartW - (data.length + 1) * barGap) / data.length));
    let x = padding.left + barGap;

    data.forEach((d, i) => {
      const barH = (d.mean / yMax) * chartH;
      const y = padding.top + chartH - barH;

      // Bar gradient - orange for totals, green for segments
      const gradient = ctx.createLinearGradient(x, y, x, padding.top + chartH);
      if(d.isTotal){
        gradient.addColorStop(0, '#f59e0b');
        gradient.addColorStop(1, '#d97706');
      } else {
        gradient.addColorStop(0, '#22c55e');
        gradient.addColorStop(1, '#16a34a');
      }
      ctx.fillStyle = gradient;
      ctx.fillRect(x, y, barWidth, barH);

      // Value label on top
      ctx.fillStyle = '#e8eaed';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.font = 'bold 12px system-ui, sans-serif';
      ctx.fillText(`n=${d.n}`, x + barWidth/2, y - 4);

      // X-axis label (rotated vertically)
      ctx.save();
      ctx.translate(x + barWidth/2, padding.top + chartH + 12);
      ctx.rotate(-Math.PI/2);
      ctx.fillStyle = '#e8eaed';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      ctx.font = '12px system-ui, sans-serif';
      ctx.fillText(d.segment, 0, 0);
      ctx.restore();

      x += barWidth + barGap;
    });

    // Title
    ctx.fillStyle = '#e8eaed';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.font = 'bold 14px system-ui, sans-serif';
    ctx.fillText('Snitt g√•ngtid per str√§cka (minuter)', padding.left, 10);
  }

  function niceMax(maxV){
    if(maxV <= 0) return 10;
    const magnitude = Math.pow(10, Math.floor(Math.log10(maxV)));
    const steps = [1, 2, 2.5, 5, 10];
    for(const s of steps){
      const val = s * magnitude;
      if(val >= maxV * 1.1) return val;
    }
    return magnitude * 10;
  }

  // Statistics functions
  function mean(arr){ return arr.length ? arr.reduce((a,b) => a+b, 0) / arr.length : 0; }
  function median(arr){
    if(!arr.length) return 0;
    const sorted = [...arr].sort((a,b) => a-b);
    const mid = Math.floor(sorted.length / 2);
    return sorted.length % 2 ? sorted[mid] : (sorted[mid-1] + sorted[mid]) / 2;
  }
  function std(arr){
    if(arr.length < 2) return 0;
    const m = mean(arr);
    const variance = arr.reduce((sum, x) => sum + (x-m)*(x-m), 0) / (arr.length - 1);
    return Math.sqrt(variance);
  }
  function quantile(arr, q){
    if(!arr.length) return 0;
    const sorted = [...arr].sort((a,b) => a-b);
    const pos = (sorted.length - 1) * q;
    const lo = Math.floor(pos);
    const hi = Math.ceil(pos);
    if(lo === hi) return sorted[lo];
    return sorted[lo] + (sorted[hi] - sorted[lo]) * (pos - lo);
  }

  // Initialize
  showEmpty();

})();
</script>
</body>
</html>
