<!doctype html>
<html lang="sv">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Gångtids-analys mellan uppehåll (Kinnekulle)</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:1rem;line-height:1.4;background:#f8fafc;color:#0f172a}
  h1{font-size:1.25rem;margin:0 0 .5rem}
  .bar{display:flex;gap:.6rem;align-items:center;flex-wrap:wrap;margin:.25rem 0 .8rem}
  .filters label{display:flex;align-items:center;gap:.35rem;background:#fff;border:1px solid #e2e8f0;border-radius:10px;padding:.35rem .55rem}
  input[type=file]{font-size:1rem}
  label{cursor:default}
  select{padding:.3rem .4rem;border:1px solid #cbd5e1;border-radius:8px;background:#fff}
  button{padding:.45rem .8rem;border:1px solid #cbd5e1;border-radius:10px;background:#fff;cursor:pointer;transition:all .15s ease}
  button:disabled{opacity:.55;cursor:not-allowed}
  button:hover:not(:disabled){transform:translateY(-1px);box-shadow:0 2px 6px rgba(0,0,0,0.08)}
  .grid{display:grid;gap:1rem;grid-template-columns:1fr}
  canvas{background:#fff;border:1px solid #e2e8f0;border-radius:12px;padding:.5rem}
  table{border-collapse:collapse;width:100%;background:#fff;border:1px solid #e2e8f0;border-radius:12px;overflow:hidden}
  th,td{border-top:1px solid #e2e8f0;padding:.45rem .6rem;text-align:left}
  th{background:#f1f5f9}
  small{color:#64748b}
  .mut{color:#64748b}
</style>
<h1>Gångtids-analys mellan uppehåll</h1>
<div class="bar">
  <input id="file" type="file" accept="application/json">
  <label><input id="mergeDir" type="checkbox" checked> Slå ihop riktningar (A↔B)</label>
  <label><input id="chkReverse" type="checkbox" checked> Tillåt båda riktningar för valt stopp-par</label>
  <span class="mut">Läs in din <code>journey_logs.json</code> (export från appen)</span>
</div>
<div class="bar filters">
  <label>Från
    <select id="selFrom" disabled><option value="">Alla</option></select>
  </label>
  <label>Till
    <select id="selTo" disabled><option value="">Alla</option></select>
  </label>
  <label>OTN
    <select id="selOtn" disabled><option value="">Alla</option></select>
  </label>
  <button id="btnClear" disabled>Rensa filter</button>
</div>
<div class="grid">
  <div>
    <canvas id="chart" width="1200" height="520"></canvas>
    <div class="mut" id="meta"></div>
  </div>
  <div>
    <h3>Snitt gångtid per segment</h3>
    <table id="tbl-summary"><thead><tr>
      <th>Segment</th><th>n</th><th>Snitt</th><th>Std</th><th>Median</th><th>P90</th><th>Min</th><th>Max</th>
    </tr></thead><tbody></tbody></table>
    <small>Alla tider i minuter. P90 = 90:e percentilen.</small>
  </div>
  <div>
    <h3>OTN som sticker ut (längre gångtider)</h3>
    <small>Definition: z-score &gt; 2 och minst 2 observationer för OTN i segmentet (respekt för filter).</small>
    <table id="tbl-outliers"><thead><tr>
      <th>Segment</th><th>OTN</th><th>n</th><th>OTN-snitt</th><th>Globalt snitt</th><th>Std</th><th>z</th>
    </tr></thead><tbody></tbody></table>
  </div>
</div>

<script>
const fileInput = document.getElementById('file');
const mergeBox = document.getElementById('mergeDir');
const reverseBox = document.getElementById('chkReverse');
const selFrom = document.getElementById('selFrom');
const selTo = document.getElementById('selTo');
const selOtn = document.getElementById('selOtn');
const btnClear = document.getElementById('btnClear');
const ctx = document.getElementById('chart').getContext('2d');
const meta = document.getElementById('meta');

let lastLogs = null;

fileInput.addEventListener('change', async (e) => {
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const text = await f.text();
  try { lastLogs = JSON.parse(text); } catch(err){ alert('Ogiltig JSON: '+err); return; }
  setupFilters(lastLogs);
  runAnalysis();
});

mergeBox.addEventListener('change', ()=> lastLogs && runAnalysis());
reverseBox.addEventListener('change', ()=> lastLogs && runAnalysis());
selFrom.addEventListener('change', ()=> lastLogs && runAnalysis());
selTo.addEventListener('change', ()=> lastLogs && runAnalysis());
selOtn.addEventListener('change', ()=> lastLogs && runAnalysis());
btnClear.addEventListener('click', ()=>{
  selFrom.value = "";
  selTo.value = "";
  selOtn.value = "";
  reverseBox.checked = true;
  runAnalysis();
});

function toDt(x){ return x ? new Date(x) : null; }
function dwellMin(s){
  const a = toDt(s.actualArrival), d = toDt(s.actualDeparture);
  if(!a || !d) return null;
  return (d - a)/60000.0;
}
function isTrueStop(st, idx, lastIdx){
  if(st.skipNoStop === true || st.skippedStop === true) return false;
  const dm = dwellMin(st);
  if(idx === 0) return true; // start (ankare för avgång)
  if(idx === lastIdx) return !!st.actualArrival; // slut: har ankomst => räknas som destination
  return (st.actualArrival && st.actualDeparture && (dm!==null && dm > 0.05)); // verkligt uppehåll
}

function buildSegments(logs, mergeDirections){
  const rows = [];
  for(const entry of logs){
    const stops = entry.stops || [];
    if(!stops.length) continue;
    const stopNames = stops.map(s=>s.name);
    const journeyId = entry.measurementId || `${entry.trainNumber||'?'}`+"||"+`${entry.date||'?'}`;
    const lastIdx = stops.length - 1;

    // Hitta start-ankare (första verkliga avgång)
    let anchorIdx = -1, anchorTime = null, anchorName = '';
    for(let i=0;i<stops.length;i++){
      const s = stops[i];
      if(isTrueStop(s, i, lastIdx) && s.actualDeparture){
        anchorIdx = i; anchorTime = toDt(s.actualDeparture); anchorName = s.name;
        break;
      }
    }
    if(anchorIdx < 0 || !anchorTime) continue;

    for(let i=anchorIdx+1;i<stops.length;i++){
      const dest = stops[i];
      // Destination måste vara ett "verkligt uppehåll" med ankomst
      if(!isTrueStop(dest, i, lastIdx) || !dest.actualArrival) continue;

      // Respektera "exkludera inkommande gångtid"
      if(dest.excludeInboundRun === true) {
        // Om destination har också ett riktigt uppehåll (dwell > 3s), flytta ankaret hit för vidare segment
        const dm = dwellMin(dest);
        if(dm !== null && dm > 0.05 && dest.actualDeparture){
          anchorIdx = i; anchorTime = toDt(dest.actualDeparture); anchorName = dest.name;
        }
        continue;
      }

      const arr = toDt(dest.actualArrival);
      if(!arr || !anchorTime) continue;
      const minutes = (arr - anchorTime)/60000.0;
      if(minutes > 0.05){ // kassera nonsens
        let from = anchorName, to = dest.name;
        let key = mergeDirections
          ? ([from,to].sort((a,b)=>a.localeCompare(b)).join(' ↔ '))
          : (from+' → '+to);

        rows.push({
          segment: key, from, to, minutes,
          OTN: entry.trainNumber, route: entry.route, date: entry.date,
          journeyId, fromIdx: anchorIdx, toIdx: i, stopNames
        });
      }

      // Flytta ankaret om destinationen verkligen stod (dwell > 3s)
      const dm = dwellMin(dest);
      if(dm !== null && dm > 0.05 && dest.actualDeparture){
        anchorIdx = i; anchorTime = toDt(dest.actualDeparture); anchorName = dest.name;
      }
    }
  }
  return rows;
}

function runAnalysis(){
  if(!lastLogs){ drawEmpty(); fillSummary([]); fillOutliers([]); meta.textContent = "Ladda en JSON-fil för att starta."; return; }
  const merge = mergeBox.checked;
  const allowReverse = reverseBox.checked;
  const filterFrom = selFrom.value || "";
  const filterTo   = selTo.value   || "";
  const filterOtn  = selOtn.value  || "";

  const rows = buildSegments(lastLogs || [], merge);

  const filtered = rows.filter(r=>{
    if(filterOtn && r.OTN !== filterOtn) return false;
    if(filterFrom && filterTo){
      const seq = r.stopNames || [];
      const a = seq.indexOf(filterFrom);
      const b = seq.indexOf(filterTo);
      if(a === -1 || b === -1) return false;
      const forwardWindow = a < b && r.fromIdx >= a && r.toIdx <= b;
      const backwardWindow = b < a && r.fromIdx >= b && r.toIdx <= a;
      if(allowReverse){
        if(!forwardWindow && !backwardWindow) return false;
      }else{
        if(!forwardWindow) return false;
      }
    }else if(filterFrom || filterTo){
      // om bara ett stopp valt, matcha om det finns i segmentet (någon riktning)
      const has = (r.from === filterFrom || r.to === filterFrom || r.from === filterTo || r.to === filterTo);
      if(!has) return false;
    }
    return true;
  });

  if(filtered.length === 0){
    drawEmpty();
    fillSummary([]);
    fillOutliers([]);
    meta.textContent = "Inga gångtider hittades med nuvarande filter.";
    return;
  }

  // Grupp per segment
  const bySeg = group(filtered, r=>r.segment);
  const summary = Object.entries(bySeg).map(([seg, arr])=>{
    const xs = arr.map(a=>a.minutes);
    return {
      segment: seg,
      n: xs.length,
      mean_min: mean(xs),
      std_min: std(xs),
      median_min: median(xs),
      p90_min: quantile(xs, 0.9),
      min_min: Math.min(...xs),
      max_min: Math.max(...xs)
    };
  }).sort((a,b)=> b.mean_min - a.mean_min);

  // Outliers: per segment + OTN vs globalt segment
  const statMap = Object.fromEntries(summary.map(s=>[s.segment, {mu:s.mean_min, sd:s.std_min||0}]));
  const bySegOTN = group(filtered, r=>r.segment+'||'+r.OTN);
  const olist = [];
  for(const [key, arr] of Object.entries(bySegOTN)){
    const [seg, otn] = key.split('||');
    const xs = arr.map(a=>a.minutes);
    const mu = mean(xs);
    const n = xs.length;
    const glob = statMap[seg] || {mu:0, sd:0};
    const z = (glob.sd>0) ? (mu - glob.mu)/glob.sd : 0;
    if(z > 2 && n >= 2){
      olist.push({segment: seg, OTN: otn, n, mean_min: mu, global_mean: glob.mu, global_std: glob.sd, z});
    }
  }
  olist.sort((a,b)=> b.z - a.z || b.mean_min - a.mean_min);

  drawChart(summary);
  fillSummary(summary);
  fillOutliers(olist);
  const filterInfo = [];
  if(filterFrom && filterTo) filterInfo.push(`Filter: ${filterFrom} → ${filterTo}` + (allowReverse ? " (båda riktningar)" : ""));
  else if(filterFrom || filterTo) filterInfo.push(`Filter: ${filterFrom||filterTo}`);
  if(filterOtn) filterInfo.push(`OTN = ${filterOtn}`);
  meta.textContent = `Observationer (segment): ${filtered.length}. Segment: ${summary.length}. ` +
                     (merge ? 'Riktningar hopslagna (A↔B).' : 'Riktningar separerade (A→B).') +
                     (filterInfo.length ? ' ' + filterInfo.join(' | ') : ' Inga filter.');
}

function setupFilters(logs){
  const stops = Array.from(new Set((logs||[]).flatMap(e=> (e.stops||[]).map(s=>s.name).filter(Boolean)))).sort();
  const otns = Array.from(new Set((logs||[]).map(e=>e.trainNumber).filter(Boolean))).sort();
  setOptions(selFrom, stops, "Alla uppehåll");
  setOptions(selTo, stops, "Alla uppehåll");
  setOptions(selOtn, otns, "Alla OTN");
  selFrom.disabled = selTo.disabled = selOtn.disabled = btnClear.disabled = false;
}

function setOptions(sel, arr, label){
  sel.innerHTML = `<option value="">${label}</option>` + arr.map(x=>`<option value="${x}">${x}</option>`).join('');
}

function group(arr, fn){
  const m = {};
  for(const x of arr){
    const k = fn(x);
    (m[k] ||= []).push(x);
  }
  return m;
}
function mean(xs){ return xs.reduce((a,b)=>a+b,0)/xs.length; }
function median(xs){ const a=[...xs].sort((x,y)=>x-y); const i=Math.floor(a.length/2); return a.length%2? a[i] : (a[i-1]+a[i])/2; }
function std(xs){ if(xs.length<2) return 0; const m=mean(xs); const v=xs.reduce((s,x)=>s+(x-m)*(x-m),0)/(xs.length-1); return Math.sqrt(v); }
function quantile(xs, q){ const a=[...xs].sort((x,y)=>x-y); if(!a.length) return 0; const p=(a.length-1)*q; const lo=Math.floor(p), hi=Math.ceil(p); if(lo===hi) return a[lo]; return a[lo] + (a[hi]-a[lo])*(p-lo); }

function drawEmpty(){
  const w = ctx.canvas.width, h = ctx.canvas.height;
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle="#000";
  ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.font="16px system-ui, sans-serif";
  ctx.fillText("Inga gångtider hittades.", w/2, h/2);
}

function drawChart(summary){
  const w = ctx.canvas.width, h = ctx.canvas.height;
  ctx.clearRect(0,0,w,h);
  const left=60, bottom=60, top=20, right=20;
  const cw = w-left-right, ch = h-top-bottom;

  const labels = summary.map(s=>s.segment);
  const values = summary.map(s=>s.mean_min);
  const maxV = Math.max(...values, 0.1);
  const yMax = niceMax(maxV);

  // Axlar
  ctx.strokeStyle="#94a3b8";
  ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(left, top); ctx.lineTo(left, top+ch); ctx.lineTo(left+cw, top+ch); ctx.stroke();

  // Grid + y ticks
  ctx.fillStyle="#0f172a";
  ctx.font="12px system-ui, sans-serif";
  ctx.textAlign="right"; ctx.textBaseline="middle";
  const ticks = 5;
  for(let i=0;i<=ticks;i++){
    const v = yMax*i/ticks;
    const y = top + ch - ch*i/ticks;
    ctx.fillText(v.toFixed(1), left-6, y);
    ctx.strokeStyle="#e2e8f0"; ctx.beginPath(); ctx.moveTo(left, y); ctx.lineTo(left+cw, y); ctx.stroke();
  }

  // Bars
  const n = values.length;
  const gap = 4;
  const bw = Math.max(6, Math.min(36, (cw - (n+1)*gap)/Math.max(n,1)));
  let x = left + gap;

  ctx.textAlign="center"; ctx.textBaseline="top";
  for(let i=0;i<n;i++){
    const v = values[i];
    const hpx = (v / yMax) * ch;
    const y = top + ch - hpx;

    ctx.fillStyle="#64748b";
    ctx.fillRect(x, y, bw, hpx);

    ctx.fillStyle="#111827";
    ctx.font="10px system-ui, sans-serif";
    ctx.textBaseline="bottom";
    ctx.fillText("n="+summary[i].n, x+bw/2, y-2);

    ctx.textBaseline="top";
    ctx.save();
    ctx.translate(x+bw/2, top+ch+4);
    ctx.rotate(-Math.PI/4);
    ctx.fillText(labels[i], 0, 0);
    ctx.restore();

    x += bw + gap;
  }

  ctx.fillStyle="#0f172a";
  ctx.font="14px system-ui, sans-serif";
  ctx.textAlign="left"; ctx.textBaseline="top";
  ctx.fillText("Snitt gångtid per segment (minuter)", left, 4);
}

function niceMax(maxV){
  const steps = [1,2,2.5,5,10,15,20,25,30,40,50];
  let mag = Math.pow(10, Math.floor(Math.log10(maxV||1)));
  for(let k of steps){
    const v = k*mag;
    if(v >= maxV*1.05) return v;
  }
  return 10*mag;
}

function fillSummary(summary){
  const tb = document.querySelector("#tbl-summary tbody");
  tb.innerHTML = "";
  for(const s of summary){
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${s.segment}</td>
      <td>${s.n}</td>
      <td>${s.mean_min.toFixed(2)}</td>
      <td>${(s.std_min||0).toFixed(2)}</td>
      <td>${s.median_min.toFixed(2)}</td>
      <td>${s.p90_min.toFixed(2)}</td>
      <td>${s.min_min.toFixed(2)}</td>
      <td>${s.max_min.toFixed(2)}</td>
    `;
    tb.appendChild(tr);
  }
}

function fillOutliers(list){
  const tb = document.querySelector("#tbl-outliers tbody");
  tb.innerHTML = "";
  if(!list.length){
    const tr = document.createElement("tr");
    tr.innerHTML = `<td colspan="7"><em>Inga avvikare hittades med nuvarande filter.</em></td>`;
    tb.appendChild(tr);
    return;
  }
  for(const r of list){
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${r.segment}</td>
      <td>${r.OTN}</td>
      <td>${r.n}</td>
      <td>${r.mean_min.toFixed(2)}</td>
      <td>${r.global_mean.toFixed(2)}</td>
      <td>${r.global_std.toFixed(2)}</td>
      <td>${r.z.toFixed(2)}</td>
    `;
    tb.appendChild(tr);
  }
}
</script>
